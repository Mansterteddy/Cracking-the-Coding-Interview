这个数据结构主要用于解决动态连通性的问题，成为Union-Find。

动态连通性的应用场景：
1、网络连接判断
如果每个pair中的两个整数分别代表一个网络节点，那么该pair就是用来表示这两个节点是需要联通的，那么为所有的pairs建立了动态连接图后，
就能够尽可能减少布线的需要，因为已经连接的两个节点会被直接忽略掉。

2、变量名等同性（类似于指针的概念）
在程序中，可以声明多个引用来指向同一个对象，这个时候就可以通过为程序中声明的引用和实际对象建立动态连接图来判断哪些引用实际上是指向
同一个对象。

动态连通性这个场景中，我们需要解决的问题可能是：
1、给出两个节点，判断它们是否连通，如果连通，不需要给出具体的路径。
2、给出两个节点，判断它们是否连通，如果连通，需要给出具体的路径。

第一种情况，一般使用Union-Find算法，第二种情况，一般使用DFS算法。

直观思路为：对于连通的所有节点，我们可以认为它们属于一个组，因此不连通的节点必然就属于不同的组，随着pair的输入，我们需要首先判断输入的
两个节点是否连通。我们将所有的节点以整数表示，即对N个节点使用0-N-1的整数表示，而在处理输入的pair之前，每个节点必然是孤立的，即属于不同的组。

初始化完毕后，可以对该动态连通图做以下操作：

1、查询节点属于的组 数组对应位置的值即为组号

2、判断两个节点是否属于同一个组 分别得到两个节点的组号，然后判断组号是否相等

3、连接两个节点，使之属于同一个组
分别得到两个节点的组号，组号相同时操作结束，不同时，将其中的一个节点的组号换成另一个节点的组号。

4、获取组的数目
初始化为节点的数目，然后每次成功连接两个节点之后，递减1

API：
UF(int N) initialized N sites with integer names (0 to N-1)
void union(int p, int q) add connection between p and q
int find(int p) component identifier for p (0 to N-1)
boolean connected(int p, int q) return true if p and q are in the same component
int count() number of components

这个数据结构的关键在于find，所有的操作都要基于find。
在每次连通两点后，需要将这些节点的组号设置为同一个组号，此时需要遍历整个数组，将某个组号修改为另一个组号，这样的时间复杂度为O(MN)，M为要添加的
新路径的数量，N是节点数量。为了提高union效率，就不能遍历整个数组。

为了quick-union，需要将节点更好地组织起来，为了使得查找和修改的效率最高，因此使用树。
为了使得树自平衡，数的构造可以采用红黑树或者AVL树。