SYNTAX 
The define Preprocessor Directive
FORM: 
#define macro-name macro-definition 
#define macro-name(parameter-list) macro-definition 
EXAMPLES: 
#define NULL 0 
#define MAX(x, y) ((x) > (y) ? (x) : (y)) 
MEANING: Subsequent to the definition, whenever the symbol macro-name 
is encountered, the preprocessor will replace it with the macro-definition. 
The macro-definition begins with the first nonspace character after the 
macro-name and ends with the last nonspace character on the same line as the 
#define directive. If there are parameters following the macro-name 
(for example, x and y in MAX(x, y)), they are replaced in the 
macro-definition with the corresponding actual arguments.

SYNTAX 
The #ifdef, #ifndef, #else, and #endif Preprocessor Directives 
FORM: 
#ifdef macro-name 
code to be included if macro-name is defined 
#else code to be included if macro-name is not defined 
#endif 
or 
#ifndef macro-name 
code to be included if macro-name is not defined 
#else 
code to be included if macro-name is defined 
#endif 
The #else is optional, but there must be an #endif to correspond to the #ifdef or #ifndef. 
EXAMPLE: 
#ifdef __cplusplus 
extern "C" { ... } 
#endif 
MEANING: 
Indicates what to include if the macro-name is defined or not defined. 
If the macro-name is defined, include all the lines of code between the 
#ifdef and the #else (if present), or between the #ifdef and the #endif 
if there is no #else. If the macro-name is not defined, include all 
the lines between the #else and the #endif (if any). 
The opposite happens if the first line begins with #ifndef.

PROGRAM STYLE 
Using Preprocessor Directives to Prevent Multiple Inclusion of an Include File 
We use include files to package function and class declarations. 
It is possible that a function or class uses other functions or classes 
that are defined in other include files. However, it is an error if 
the same function declaration or class declaration is presented to the 
compiler more than once. When you write an include file, you do not know 
when it is going to be used or by what programs, so each include file 
should be guarded using preprocessor directives to ensure that it is 
included only one time. The way this is done is to begin the include file 
with two directives of the form: #ifndef unique-name #define unique-name 
where unique-name, as the place holder implies, is a unique name. 
Generally the file name is converted to uppercase, the period that separates
the name from the extension is replaced by an underscore, and a trailing 
underscore is added. Thus the include file myfile.h would use MYFILE_H_ as 
the unique name. You may see other conventions. The last line of the 
include file is an #endif directive. The first time the preprocessor sees 
the #ifndef directive, the unique-name will not be defined. 
Thus the lines that follow will be processed by the preprocessor and passed 
on to the compiler. The #define directive will define unique-name 
so that the next time the preprocessor sees the include file, 
the #ifndef will be false and the file will be skipped. Note again that
the last line of the file should be #endif.

PROGRAM STYLE 
Braces and Indentation in Control Statements C++ programmers often place 
the opening brace { on the same line as the control statement header. 
The closing brace } aligns with the first word in the control statement header.
We will always indent the statements inside a control structure to clarify 
the meaning of the control statement. Although we write the symbols } 
else { on one line, another popular style convention is to place the word else 
under the symbol } and aligned with if: 
if (next_int % 2 == 0) { 
    sum += next_int; 
} 
else { 
prod *= next_int; 
} 
Some programmers omit the braces when a true task or false task or a loop 
body consists of a single statement. Others prefer to include them always, 
both for clarity and because having the braces will permit them to insert 
additional statements later if needed.

PITFALL 
Omitting Braces Around a Compound Statement 
The braces in the preceding example delimit compound statements. 
Each compound statement consists of two statements. 
If you omit a brace, you will get the syntax error 'else' without 'if'. 

PROGRAM STYLE 
Writing if Statements with Multiple Alternatives 
C++ programmers often write nested if statements like those in the 
preceding example without indenting each nested if. The following 
multiple-alternative decision has the same meaning but is easier to write 
and read. 
if (operator == '+') { 
    result = x + y; 
    add_op++; 
} else if (operator == '-') { 
    result = x - y; 
    subtract_op++; 
} else if (operator == '*') { 
    result = x * y; 
    multiply_op++; 
} else if (operator == '/') { 
    result = x / y; 
    divide_op++; 
}


PROGRAM STYLE 
C++ Convention for Identifiers 
Many C++ programmers use lowercase words or phrases for variable names. 
Words are separated using the underscore character. 
For classes it is common to use a word or words that begin with an initial 
uppercase letter. However, the C++ standard uses lowercase for both 
variable and class names. Identifiers that are in all uppercase are 
used for macros. Another convention that is becoming popular is 
“camel notation” for variable names. All letters are in lowercase except for 
identifiers that are made up of more than one word. 
The first letter of each word, starting with the second word, 
is in uppercase (for example, thisLongIdentifier). 
Camel notation gets its name from the appearance of the identifier, 
with the uppercase letters in the interior forming “humps.”

PITFALL 
Using Increment and Decrement in Expressions with Other Operators 
In the preceding example, the increment operator is used with the 
assignment operator in the same statement. Similarly, the expression 
x * i++ uses the multiplication and postfix increment operators. 
In this expression, the variable i is evaluated and then incremented. 
When the prefix form is used in an expression (for example, x * ++i), 
the variable i is incremented before it is evaluated. 
However, you should avoid writing expressions like these, 
which could easily be interpreted incorrectly by the human reader.

SYNTAX 
Object Declaration
FORM: 
type-name name; 
type-name name = initial-value; 
type-name name(parameter-list); 
EXAMPLE: 
int i; 
string s = "hello"; 
double x = 5.5; 
double y(6.7); 
point p(x, y);
MEANING: 
The specified name is declared to reference an object of the 
specified type-name. Memory for this object is allocated and initialized to 
the specified value. In the first example, the name i refers to an int object,
with an unspecified initial value. In the third and fourth examples the 
names x and y refer to double objects with the initial values 5.5 and 6.7, 
respectively. Note that the two forms used to initialize x and y are 
equivalent. In the final example p refers to an object of type point 
(a class type) with the initial value (x, y). 

SYNTAX 
Pointer Declaration
FORM: 
type-name* pointer-variable; 
type-name* pointer-variable = &object; 
EXAMPLE: 
int* k; 
int* k = &count; 
MEANING: 
The value of the pointer-variable will be a memory address. 
If the initial value begins with the prefix &, as in &object, 
the pointer-variable is initialized to the memory address of object.

SYNTAX 
Address-Of Operator &
FORM: &object 
EXAMPLE: &k; 
MEANING: Gives the address (memory location) of object.

SYNTAX 
Dereferencing Operator * 
FORM: 
*pointer-variable 
EXAMPLE: 
*px; 
MEANING: 
Gives the object referenced by pointer px. The data associated with this 
object value can be accessed or changed. For example, if px is type double*,
the statement *px = 25.0; stores 25.0 in the object referenced by px. 
The statement *px = *px + 2.5; changes the value of this object to 27.5.

PROGRAM STYLE 
Use of T* v versus T *v to Declare a Pointer Variable 
Programmers generally use one of the following statements to declare a pointer
variable. double* px; double *px; The argument in favor of the first form 
is that it clearly states that px is of type double* (that is, 
a pointer to double). The second form states that the expression *px is 
of type double (and therefore px is of type pointer to double). 
The second form is technically more correct, since this is how the compiler 
interprets it. Which one you use is a matter of personal taste as long as you 
declare each variable individually. 

PITFALL 
Declaring Multiple Pointer Variables in One Declaration 
You may also declare multiple variables of the same type in one 
declaration statement. In that case you must remember that the compiler 
binds the * to the variable and not the type. Thus the declaration 
double* px, py; declares that px is a pointer to double, but that py is a 
double! To declare both px and py to be pointers we need to use the 
declaration double *px, *py;

PROGRAM STYLE 
Use of NULL versus 0 The choice of using NULL or 0 to represent the null 
pointer is the subject of much discussion among C++ programmers. 
The C++ standards committee is currently working on a revision to 
the C++ standard. One of the proposed changes is to define a true null 
pointer constant as a new reserved word in the language. 

SYNTAX 
The new Operator 
FORM: 
new type-name 
new type-name(initial-value) 
new class-name(parameters) 
EXAMPLE: 
new double; 
new double(1.23456); 
new std::string(line, 5, 10) 
MEANING: 
Memory is allocated for an object of type type-name. If an 
initial-value or list of parameters is provided, those values are 
placed in the new object. (In the case of an object of class type, 
these actions are carried out by a call to the constructor for the class 
that takes these parameters. Constructors will be discussed in Chapter 1.) 
A pointer to the created object is returned. The first of the foregoing 
examples creates a double object and returns a pointer to it. 
The second example creates a double object, initializes its value to 1.23456, 
and returns a pointer to it. The third example creates a new string object
and initializes it to the substring of the string line that begins at the 
fifth character and has a length of 10 characters.

SYNTAX 
The delete Operator 
FORM: 
delete pointer-variable; 
EXAMPLE: 
delete px; 
MEANING: 
The memory occupied by the object pointed to by px is returned to the free 
memory pool. (If the object is of class type, 
the destructor function for the class is called first; 
destructors will be discussed in Chapter 1.) 
Note that the pointer variable must point to an object that was created 
via the new operator.

PITFALL 
Out-of-Bounds Subscripts 
C++ allows you to use an array subscript that is outside of the array bounds. 
For example, if you attempt to reference scores[5], 
a C or C++ compiler would access the first memory cell following the array scores. 
This is considered an error, but it is not detected by the run-time system 
and will probably lead to another error that will be detected further 
down the road (before it does too much damage, you hope).

SYNTAX 
The new[] Operator
FORM: 
new type-name[expression] 
EXAMPLE: 
new string[n] 
MEANING: 
Space is allocated for an array of type-name objects of length expression.
A pointer to the first element of this array is returned.

SYNTAX 
The delete[] Operator
FORM: 
delete[] pointer; 
EXAMPLE: 
delete[] students; 
MEANING: 
The dynamically allocated array whose first element is pointed to by pointer 
is deleted and returned to the free storage pool. Note that the array 
must have been allocated using the new[] operator. 

PROGRAM STYLE 
Use of at Versus the Subscript Operators 
If names is a string, you can reference the character at position index 
using either names.at(index) or names[index]. The use of at has the advantage 
that if the index is not valid, the program is aborted as a result of an exception 
being thrown. (Exceptions are discussed in Chapter 2.) However, despite this advantage,
C++ programmers generally prefer to use the latter form because it is simpler.

PITFALL
If you extract the last value on a data line using the extraction operator 
>> and then use getline, you will get a surprising result. 
There will still be an unprocessed \n character at the end of the data line, 
so the function call 
getline(cin, name, '\n'); 
would extract just the '\n' character, 
and an empty string would be stored in name. Consequently, you must first skip 
over the '\n' character (using function ignore) before calling getline to 
read the characters typed in on the next line. 
// Skip all characters through the first '\n' 
cin.ignore(numeric_limits<int>::max(), '\n');   
getline(cin, name, '\n'); 

SYNTAX 
Class Definition
FORM: 
class name { 
public: 
    member declarations 
private: 
    member declarations }; 
EXAMPLE: 
See Listing 1.1.
MEANING: 
The class name is defined to have the members listed. 
Members may be either data members (also called data fields), 
member functions (also called functions), or nested classes. 
Members that are declared following the access specifier 
public: are accessible by functions outside of the class, 
while those following the access specifier 
private: are accessible only by functions that are members of the class 
or are declared to be friends of the class. 
There may be multiple public and private regions, 
but generally all public members are declared together, 
followed by all private members. 
Also, declarations that precede the first access specifier are 
considered to be private.

SYNTAX 
Member Function Definition 
FORM: 
return-type class-name::function-name(parameter list) const(opt) { body } 
EXAMPLE: 
int Clock::get_hours() const { return hours; } 
MEANING: 
The function function-name that is a member of the class class-name is 
defined by the sequence of statements provided in the body. 
The declaration portion of the definition must be the same as that given 
in the class definition with respect to the return type, 
function name, types of parameters, and const specifier. 
The subscript opt following the const specifier indicates that it is optional. 
However, if it is present in the function declaration, it must also be 
present in the corresponding function definition. 
If these do not match, the compiler will report an error such as 
“function-name is not a member of class-name.” 

PROGRAM STYLE 
Explicit Namespace Qualification in Include Files 
You will notice that the include file included the standard headers 
<string> and <iostream>, but it did not contain a using directive 
such as using namespace std; Instead we specifically qualified the classes 
string and ostream with the prefix std::. This is because we do not know 
whether the client program will include the using directive. 
In Chapter 3 we will see reasons why this may not be desirable. 
It is considered good program style to always use explicit namespace 
qualification in header files.

SYNTAX 
Constructor Definition 
FORM: 
class-name(parameters) : initialization-expressions { body } 
EXAMPLES: 
Person(std::string first, std::string family, std::string ID, int birth) : given_name(first), family_name(family), ID_number(ID), birth_year(birth) { } 
Person() : given_name(""), family_name(""), ID_number(""), birth_year(1900) { } 
MEANING: 
A constructor has the same name as its class and has no return type. 
A constructor is called automatically when an object is created. 
Its purpose is to initialize the memory allocated to the object to initial 
values. Constructors may have parameters, and constructors having different 
parameter lists may be defined. The initialization-expressions are of the form 
data-field-name(initial-value). As the object is constructed, the named data 
fields are set to the given initial values. After the object is constructed, 
the body of the constructor is then executed. 

PROGRAM STYLE 
Use of Initialization Expressions in Constructors 
It is preferable to use initialization expressions to initialize data fields 
rather than using assignment statements in the body. 
Initialization expressions have the form data-member(initial-value-expression) 
An initialization expression such as given_name(first) is evaluated as 
the object is being constructed. If there is no initialization 
expression for a class data field, it may be initialized to a default value. 
The body is executed after the object is constructed. 
Thus, if you initialize a class data field in the body using an assignment 
statement 
given_name = first; 
you are effectively initializing it twice. 
While this does not matter for the built-in types 
because they have no default initialization, 
it is significant for class types, which may have 
several data fields of their own to initialize.

PROGRAM STYLE 
Inline Definition of Constructors, Accessors, and Modifiers 
It is a good programming practice to separate the declarations of the 
member functions from their definitions. The public portion of a class 
definition is its interface. This is how clients view the class. 
If the function definition is included in the class definition, 
the client programs include the function definition into their own code. 
Then, if we want to change a function’s implementation, we force the 
client programs to change. There are two reasons for making an 
exception for constructors, accessors, and modifiers. 
First of all, if a function definition is included in a class definition, 
the compiler treats this function as an inline function. 
That is, the compiler replaces a call to that function with the 
code contained in the function body. 
Such code executes faster. 
Second, constructors, accessors, and modifiers generally are very simple 
and are unlikely to change. Constructors generally consist only of 
initialization expressions; accessors generally consist of a return 
statement, and modifiers generally consist of a single assignment statement. 
Although we did not insert the accessor function definitions for class 
Clock in the public part of file Clock.h; it would have been permissible, 
and even desirable, to do this.

SYNTAX 
Operator Declaration 
FORM: 
return-type operator operator-symbol(parameter) const; 
EXAMPLES: 
bool operator==(const Person& per) const; 
bool operator!=(const Person& per) const; 
MEANING: 
The operator specified by operator-symbol is defined for this class. 
The left-hand operand is the current object; 
the right-hand operand is specified by parameter in the same way as a function 
parameter. If the word const appears at the end of the declaration, 
the left-hand operand is not changed by the operator.

PROGRAM STYLE
Returning a Boolean Value 
Some programmers unnecessarily write if statements to return a Boolean value. 
For example, instead of writing 
return ID_number == per.ID_number; 
they write 
if (ID_number == per.ID_number) 
    return true; 
else 
    return false; 
Resist this temptation. The return statement by itself returns 
the value of the if statement condition, which must be true or false. 
It does this in a clear and succinct manner using one line instead of four.

PITFALL
Referencing a Data Field or Parameter Hidden by a Local Declaration 
If you happen to declare a local variable (or parameter) with the same 
name as a data field, the local declaration hides the data field declaration, 
so the C++ compiler will translate the use of that name as 
meaning the local variable (or parameter), not the data field. 
So, if birth_year was also declared locally in class Person, 
the statement 
birth_year++; 
would increment the local variable, but the data field value would not change.

SYNTAX 
UML Syntax
In UML class diagrams, the + sign next to the function names indicate 
that these functions are public. The – sign next to the attributes name and 
number indicate that they are private. For the class Directory_Entry we 
show the types of the attributes, and the parameter types and 
return types of the member functions. 
Showing this information on the diagram is optional. 
We will generally show this information in separate tables such as 
Table 1.9. Appendix B provides a summary of UML.
 
PITFALL
Returning –1 (Failure) Before Examining All Array Elements 
A common logic error is to code the search loop for function find as follows: 
for (int i = 0; i < size; i++) { 
    if (the_directory[i].get_name() == name) { 
        return i; 
        } else { 
            return –1;  // Incorrect! – tests only one element. 
        } 
    } 
This loop incorrectly returns a result after testing just the first element.  

PITFALL 
Failure to Delete Dynamically Allocated Arrays 
If we do not return the storage allocated to the old array to the 
free-memory pool, this memory is lost. This is known as a memory-leak. 
Although modern computers seem to have infinite memory, 
there is in fact only a finite supply. Furthermore, 
programs that leak memory can impact other programs running on the same 
computer. A program that routinely leaks memory can eventually 
require you to reboot your computer.

PROGRAM STYLE 
Type Casting in C++ Versus C or Java 
In the type cast double(sum) the target data type is used as an operator, 
and the expression being cast is enclosed in parentheses. 
You could also use the C or Java form for type casting: 
(double) sum 
but it is not the preferred form.

PROGRAM STYLE 
Using a bool Result to Indicate Success or Failure 
What is gained by returning a bool value when we execute function 
set_element_of_x? The caller of the function can use this result to 
display an error message to the program user if desired. 
The following if statement applies function set_element_of_x to array x and 
writes an error message to stream cerr: 
if (!set_element_of_x(index, val)) 
    cerr << "*** ERROR – index value " << index << " is out of bounds. ***\n";

PITFALL 
Buffer Overruns Cause Security Holes 
Many of the security holes in programs are due to buffer overruns, 
which are a type of array-index-out-of-bounds error. 
A malicious program sends a large input stream to a program that does 
not check to see that the data fits into the array allocated to receive it. 
By modifying data outside of the allocated array, the malicious program 
is able to take over control of the target computer.

PROGRAM STYLE 
Initialize Pointers to NULL 
Although your program crashes if it attempts to dereference a null pointer, 
this is much better than having an error go unreported. C++ does not assign 
default values automatically to pointers when they are allocated. 
Until a pointer is assigned a value, it may point to anything at all. 
For this reason, it is a good practice to initialize a pointer to NULL 
when you first declare it. This way, if you attempt to dereference 
such a pointer before it is given an initial value, you will know about it.

SYNTAX 
The throw Statement
FORM: 
throw expression; 
EXAMPLES:  
throw "The value of index is out of range"; 
throw std::out_of_range("The value of index is out of range"); 
MEANING: 
The normal sequence of execution is interrupted, and control is 
transferred to the nearest exception handler whose parameter type matches 
the type of the expression. An exception handler is like a function, 
and the rules for matching an exception handler are the same as the 
rules for matching an overloaded function. If the current function 
body contains no such handler, then control is returned to the 
calling function, and a search is made from the point of the call. 
This process is repeated until the corresponding exception handler is 
found or until the main function is reached. 
If no exception handler is found, then the program terminates. 

SYNTAX The try Block
FORM: 
try { 
code that may throw an exception 
} catch (type-1 parameter-1) { 
statements to process type-1 
} catch (type-2 parameter-2) { 
statements to process type-2 
} ... catch (type-n parameter-n) 
statements to process type-n } 
EXAMPLE: 
try { 
val = get_element_of_x(10); 
} catch (std::out_of_range& ex) { 
cerr << "Out of range exception occurred\n"; 
cerr << ex.what() << endl; 
abort();    
// Exit with an error indication. } 
MEANING: 
The statements in the try block execute through to completion 
unless an exception is thrown. 
If there is an exception handler for the exception, 
its body executes to completion. 
If there is no exception handler that matches the exception, 
then the exception is passed up the call chain until 
either it is caught by some other function in the call chain 
or it is processed by the run-time library as an uncaught exception. 
If there are multiple catch blocks, 
they are checked in the order in which they appear. 
 
PITFALL 
Unreachable Exception Handler 
Note that only the first exception handler (catch block) that has an 
appropriate exception type executes. All other exception handlers are 
skipped. If an exception handler’s parameter type is derived from the class 
in an earlier exception handler, the earlier handler will match that type 
as well, and the later exception handler cannot execute. In this case 
the C++ compiler will issue a warning message. 
To correct this error, switch the order of the exception handlers 
so that the exception handler for the derived class type comes first. 

PROGRAM STYLE 
Using Exceptions to Enable Straightforward Code 
In computer languages that did not provide exceptions, 
programmers had to incorporate error-checking logic throughout 
their code to check for many possibilities, some of which were of 
low probability. The result was sometimes messy, as follows: 
Step A 
if (Step A successful) { 
Step B 
if (Step B successful) { 
Step C 
} else { 
Report error in Step B 
Clean up after Step A 
} 
} else { 
Report error in Step A 
} 
With exceptions this becomes much cleaner, as follows: 
try { 
Step A 
Step B 
Step C 
} catch (exception indicating Step B failed) { 
Report error in Step B 
Clean up after Step A 
} catch (exception indicating Step A failed) { 
Report error in Step A 
}

SYNTAX 
Assertion Statement
FORM: 
assert(expression); 
EXAMPLE: 
assert(x == 5); 
INTERPRETATION: 
If the expression evaluates to false, then the program writes an error 
message and aborts. The error message includes the expression that 
failed, the source file name, and the line number of the assertion statement.

SYNTAX 
Defining a Derived Class 
FORM: 
class derived-class : public base-class { ... } 
EXAMPLE: 
class Lap_Top : public Computer { ... } 
MEANING: 
The class derived-class inherits the member functions and data fields from the class 
base-class.

PITFALL 
Neglecting the Keyword public When Declaring a Derived Class 
If we omit the keyword public when we declare a derived class, we will declare a 
derived class with private inheritance. This means that the derived class will 
inherit the data fields and functions of the base class, but they will not be visible 
to client classes. Effectively, the derived class contains a private data field 
that contains a base-class object. This is another way to represent the has-a 
relationship.

PITFALL 
Not Defining the No-Parameter Constructor 
If no constructors are defined for a class, the no-parameter constructor for that class 
will be provided by default. However, if any constructors are defined, 
the no-parameter constructor must also be defined explicitly if it needs to be invoked. 
C++ does not provide it automatically in this case, because it may make no sense to 
create a new object of that type without providing initial data field values. 
(It was not defined in class Lap_Top or Computer because we want the client to specify 
some information about a Computer object when that object is created.) 
If the no-parameter constructor is defined in a derived class but is not defined 
in the base class, you will get a syntax error. For example, the g++ compiler 
displays an error such as no matching function call to class_name::class_name() 
You can also get this error if a derived-class constructor does not explicitly 
call a baseclass constructor. There will be an implicit call to the 
no-parameter base-class constructor, so it must be defined.

SYNTAX 
Calling Base-Class Functions
FORM: 
base-class::function-name() 
base-class::function-name(argument-list) 
EXAMPLE: 
Computer::to_string() 
MEANING: 
Using the prefix base-class:: in a call to function function-name 
calls the function with that name defined in the base class of 
the current class.

SYNTAX 
Declaring a Pointer Type
FORM: 
type-name* variable-name; 
EXAMPLE: 
Computer* the_computer; 
MEANING: 
The variable variable-name is declared to be of type 
pointer-to-type-name. As discussed in the C++ Primer, a pointer 
is an object that contains the address of another object. 
To reference the object pointed to by a pointer variable, 
use either the dereferencing operator * (for example, *the_computer) 
or the pointer class member access operator -> (for example, 
the_computer->). Pointers are initialized using either 
the address-of operator (&) or the new operator.

SYNTAX 
Creating New Objects Using the new Operator
FORM: 
new type-name; 
new type-name(argument-list); 
EXAMPLE: 
new Computer("Acme", "Intel P4 2.4", 512, 60); 
MEANING: 
Memory is dynamically allocated for a new object of type type-name 
and the constructor is then called to initialize the object. 
A pointer to the newly created object is the value of this 
expression. 

SYNTAX 
Accessing an Object Through a Pointer (the Dereferencing Operator *)
FORM: 
*pointer-variable 
EXAMPLE: 
*the_computer 
MEANING: 
The expression *pointer-variable is a reference to the object 
pointed to by pointer-variable. When used on the right-hand 
side of an assignment, it is the value of the object: 
Computer my_computer = *the_computer; 
Now, my_computer contains a copy of the Computer object 
referenced by the pointer variable the_computer. 
When used on the left-hand side of an assignment 
*the_computer = your_computer; 
then the referenced object is assigned the value of 
the right-hand side.

SYNTAX 
Accessing a Class Member through the Class Member Access Operator
FORM: 
pointer-variable->member-name 
EXAMPLE: 
the_computer->to_string(); 
my_ram = the_computer->ram_size; 
the_computer->ram_size = 1024; 
MEANING: 
The expression pointer-variable->member-name is a reference to 
the member of the object pointed to by pointer-variable. 
If member-name is a function, then that function is called. 
If member-name is a data field, then when the expression is 
used on the right-hand side of an assignment, it is the value of 
the data field. When the expression is used on the left-hand 
side of an assignment, then the referenced data field is assigned 
the value of the right-hand side. The expression 
pointer-variable->member-name 
is equivalent to 
(*pointer-variable).member-name 
but the -> operator is considered easier to read. 
Also, the -> operator can be overloaded, but the dot operator cannot.

PROGRAM STYLE 
When to Reference an Object through a Pointer Variable 
You have seen two different ways to create and reference 
Computer objects: Computer my_computer("Acme", "Intel P4 2.4", 512, 60); 
Computer* my_computer = new Computer("Acme", "Intel P4 2.4", 512, 60); 
What is the difference between these two statements? 
The first creates a type Computer object and references it through variable my_computer 
(for example, my_computer.to_string()). The second creates a Computer object and references 
it through a pointer to a Computer variable (for example, my_computer->to_string()). 
Use the first approach when you want the variable my_computer always to reference 
an object that is type Computer. Use the second approach when you want flexibility; 
it allows my_computer to reference an object of type Computer or any of its derived classes. 

SYNTAX 
Virtual Function Definition 
FORM: 
virtual function-declaration; 
virtual function-declaration { function-body } 
EXAMPLE: 
virtual std::string to_string() const; 
MEANING: 
If the function declared by function-declaration is overridden in a derived class, 
and if this function is called through a pointer to (or reference to) the base class, 
then the function body associated with the actual object pointed to (or referenced) 
will be executed. If a function is declared virtual in a base class, it continues 
to be virtual in all derived classes. It is, however, a good practice to include the 
virtual declaration in the derived classes too, for documentation purposes.

PITFALL 
Failure to Declare a Member Function virtual in a Base Class 
Generally, when we override a function, we intend to use polymorphism to 
reference objects of it and its derived classes. However, 
if we omit the keyword virtual, then the C++ compiler will determine 
the function to be called at compile time, based on the type of the pointer 
and not on the type of the object pointed to.

PITFALL 
Overridden Member Functions Must Have the Same Return Type 
If you write a member function in a derived class that has the same signature 
as one in the base class but a different return type, you will get an error message.

PROGRAM STYLE 
Declaring a virtual Destructor 
A class’s destructor is called when an object of that class is deleted or goes out of scope. 
Its purpose is to release any resources (such as dynamically allocated memory for 
classtype data members) that the class owns. Suppose a derived-class object is 
created using the new operator, and the pointer to it is stored in a pointer to 
the base-class variable. If the destructor is not virtual, then only the base-class 
destructor will be called when the delete operator is invoked through the pointer. 
Therefore, when you declare a member function to be virtual in a class, you should 
always declare the destructor virtual even if the destructor does nothing. 
In our Computer class example we should include the following: 
virtual ~Computer() {} 
This declares a virtual destructor that performs no operation. 
Some compilers will issue a warning message if the virtual destructor is omitted.

SYNTAX 
Abstract Function Definition 
FORM: 
virtual function-declaration = 0; 
EXAMPLE: 
virtual double percent_protein() const = 0; 
INTERPRETATION: 
The function declared by function-declaration is declared to be an abstract function. 
The expression = 0; 
is given in place of the function body and must be specified in the class declaration. 
You may also see the term pure virtual function to refer to an abstract function.

PITFALL 
Omitting the Definition of an Abstract Function in a Derived Class 
If you write class Vegetable and forget to define member function percent_protein, 
the class Vegetable will also be abstract. If you subsequently 
attempt to declare an object of type Vegetable, you will get a syntax error. 

DESIGN CONCEPT 
The Importance of Strong Typing 
Suppose C++ did not check the expression type and simply performed the assignment 
Lap_Top* a_laptop = new Computer( ... );    // Incompatible types 
Further down the line, we might attempt to apply a Lap_Top function to the object 
referenced by a_laptop. Because a_laptop is type Lap_Top*, the compiler would 
permit this. If a_laptop were pointing to a type Lap_Top object, 
then performing this operation would do no harm. But if a_laptop were 
pointing to an object that was not type Lap_Top, 
performing this operation would cause either a run-time error or 
an undetected logic error. It is much better to have the compiler 
tell us that the assignment is invalid.

SYNTAX 
Dynamic Cast 
FORM: 
dynamic_cast<class-name*>(object-name) 
EXAMPLE: 
dynamic_cast<Lap_Top*>(a_computer) 
INTERPRETATION: 
A pointer of type class-name is created to object object-name, 
provided that object-name is an actual object of type class-name 
(or a derived class of classname). If object-name is not type class-name, 
the result is a null pointer.

PITFALL 
Run-time Type Identification 
If you are using a Microsoft compiler, you may get a warning message 
that Run-time Type Identification is needed. 
You must set a compiler switch (/GR) to enable this or dynamic_cast will cause a 
run-time error.

SYNTAX 
Namespace Declaration 
FORM: 
namespace name { ... }
EXAMPLE: 
namespace game { ... }
INTERPRETATION: 
All identifiers (e.g., functions, variables, etc.) defined within the block 
following the name are within that namespace. Namespaces are open; 
this means that you may have more than one namespace declaration with 
the same name in your program. The identifiers defined within the different 
declarations are merged.

PROGRAM STYLE 
When to Use Namespaces 
The default namespace facility is intended for use during the early stages of 
implementing classes or for small prototype programs. If you are developing an 
application that has several classes that are part of a hierarchy of classes, 
you should declare them all to be in the same namespace. 
The namespace declaration will keep you from accidentally referring to classes by 
their short names in other classes that are outside the namespace.

SYNTAX 
using Declaration 
FORM: 
using namespace::name; 
EXAMPLE: 
using std::cout; 
MEANING: 
The qualified name is now a member of the namespace in which the using declaration appears. 
In this example, we can now use the name cout without prefixing the namespace qualifier 
std:: in front of it.

SYNTAX 
using Directive 
FORM: 
using namespace namespace-name; 
EXAMPLE: 
using namespace std; 
MEANING: 
All of the names defined in namespace-name are now defined as such within the current 
namespace.

PROGRAM STYLE 
A using Declaration Versus a using Directive 
You are probably in the habit of beginning your programs as follows: 
#include <iostream> 
// Other include directives 
using namespace std; 
... 
As long as your programs are small, this generally does not cause a problem. 
But you should recognize that the standard library is quite large and defines a 
very large number of names. In many implementations the include directive 
#include <iostream> brings in a large number of other headers. 
Many of these headers you would expect, such as <istream> and <ostream>, 
but it also may include some headers that you never heard of, such as <locale>, 
and others you may not expect, such as <string>. Therefore, if your program is going to 
access only cout, then a using declaration is preferred: 
#include <iostream> 
// Other include directives 
using std::cout; 
...

PROGRAM STYLE 
using Declarations and using Directives in Header Files 
Our definition of the class Person included a component of the class string from 
the standard library. You may be wondering why we didn’t write the header file as: 
#ifndef PERSON_H_ 
#define PERSON_H_ 
#include <string> 
using namespace std; 
class Person { 
... 
string name; 
}; 
Now assume that you start to write the game program we discussed in Example 3.6 and 
define your own class map. You decide that you need a Person class in your game program 
and use this revised header. Because class Person brings in all the names from 
namespace std, the game program will not compile, because there is now a 
name clash between your map and the standard map! Therefore, you should never 
place a using declaration or using directive inside a header file. Instead 
you should always explicitly qualify all names that are defined in a namespace 
with their namespace name; 
for example, 
std::cout.

SYNTAX 
friend Declaration 
FORM: 
friend function-name; 
friend class class-name; 
EXAMPLE: 
friend foo; 
MEANING: 
The named function or class is granted access to the private and 
protected members of the class in which the friend declaration appears.

SYNTAX 
Instantiating a Template Class
FORM: 
template-class-name<argument-list> object-name; 
EXAMPLE: 
some_container<int> call_lengths; 
some_container<Person> people; 
MEANING: 
If one doesn’t already exist, a distinct copy of the template class is created by 
substituting the arguments for the parameters. This is very similar to what happens 
when a function is called, except that this substitution occurs when the program 
is being compiled. Generally the arguments are types (either built-in or class types). 
In this example, two versions of the template class some_container are created: one to 
hold ints and the other to hold People objects. The classes some_container<int> and 
some_container<People> are distinct classes. 

PROGRAM STYLE 
Use of operator[] versus at 
As discussed in Chapter 2, the fact that C++ does not perform range checking on array 
bounds has led to many problems, including many security holes in modern operating systems. 
Unlike function at, the standard vector subscripting operator does not perform range 
checking, leaving the door open for these problems. Although the subscripting operator 
is more error prone, it is also more convenient to use, so most programmers use it 
rather than member function at. In the next section, we show how you to 
redefine the subscripting operator to perform range checking.

SYNTAX 
Defining a Template Class
FORM: 
template<formal-parameter-list> class class-name { ... } 
EXAMPLE: 
template<typename Item_Type> class vector { ... } 
template<class Item_Type> class bag { ... } 
template<typename Item_Type, size_t MAX_SIZE> class bounded_list { ... } 
MEANING: 
The class class-name is defined to take one or more template parameters. 
A template parameter follows the same syntax as a function parameter. 
type-name parameter-name 
where type-name is the name of the parameter’s type, and parameter-name is the 
identifier that is used to designate this parameter. Generally you use the keyword 
typename or the keyword class for type-name. This indicates that the parametername is to 
be treated as a type within the body of the template class. You can also declare 
additional parameters for the template class that are built-in types or previously 
defined class types (see the last example above). 
Note: The original C++ syntax used class to designate either classes or built-in types 
as template parameters, but the C++ standard introduced the alternative usage of typename 
as being a more accurate term. While typename is the preferred usage for new applications, 
the C++ standard uses class.

PROGRAM STYLE 
Using the Postfix (or Prefix) Operator with a Subscript 
Some programmers prefer to combine the last two statements in the push_back function 
and write them as the_data[num_items++] = the_value; This is perfectly valid. 
C++ uses the current value of num_items as the subscript for array access 
and then increments it. The only difficulty is the fact that two operations 
are written in one statement and are carried out in a predetermined order. 
If you are unsure of the order, you might select prefix increment when you needed 
postfix increment, or vice versa.

SYNTAX 
Defining the Destructor 
FORM: 
~class-name() {body} 
EXAMPLE: 
~vector() {delete[] the_data;} 
INTERPRETATION: 
The function named ~class-name is the destructor for the class class-name. 
The purpose of the destructor is to supplement any actions taken by the default destructor. 
Specifically, it is to release any resources owned by the object, such as dynamically 
allocated memory. 

类中什么时候使用this？
类中的变量和函数是隐式调用this的，也就是说可以不用写明this，就可以调用类中变量和成员函数
1、当类中的名字和局部变量同名时
2、要返回这个对象本身时。

PITFALL 
Failure to Define the Assignment Operator, Copy Constructor, and Destructor 
If a class dynamically allocates a resource such as dynamically allocated memory, 
then it must define the assignment operator, copy constructor, and destructor. 
This is known are the “rule of three.” Generally, if you define one of these three 
functions in a class, you must define all three of them, since they have to work 
consistently. If you define the assignment operator and not the copy constructor, 
then copies made by one may not be the same as copies made by the other. 
For example, the default copy constructor and assignment operator make shallow copies. 
If you define only a copy constructor that makes a deep copy, it will not work 
consistently with the default assignment operator. If you omit the destructor, 
then there is a potential for a memory leak.

PROGRAM STYLE 
Use of struct 
The keywords class and struct are effectively synonymous in C++. The only difference 
is that members of classes are private by default, whereas members of structs are 
public by default. Most C++ programmers have adopted the practice of using struct 
only to define a grouping of data that is to be publicly accessible. 
The only member functions defined are simple constructors that initialize the data. 
Such structs are known as “Plain Old Data” (POD) and can be used as function 
parameters to functions written in other programming languages such as C.

PITFALL 
Falling Off the End of a List 
If node_ptr is at the last list element and you execute the statement 
node_ptr = node_ptr->next; 
node_ptr will be set to NULL, and you will have fallen off the end of the list. 
This is not an error. However, if you execute this statement again, 
you will probably get a run-time error. The exact error message is operating system 
dependent, as discussed in Chapter 2.

PROGRAM STYLE 
Testing Whether There Are More List Nodes to Process 
When testing whether there are more elements of an array or vector to process, 
we evaluate an expression of the form index < array_size, which will be true or false. 
However, we test whether there are more nodes of a list to process by comparing the 
current iterator position (iter) with a_list.end(), the iterator position just past the
 end of the list. We do this by evaluating the expression iter != a_list.end() instead of 
 iter < a_list.end(). The reason we use != instead of < is that iterators effectively are 
 pointers to the individual nodes and the physical ordering of the nodes within memory is 
 not relevant. In fact, the last node in a linked list may have an address that is 
 smaller than that of the first node in the list. Thus, using iter < a_list.end() 
 would be incorrect because the operator < compares the actual memory locations 
 (addresses) of the list nodes, not their relative positions in the list. 
 The other thing that is different is that we use prefix increment (++iter) instead of 
 postfix increment with iterators. This results in more efficient code.

PITFALL 
Attempting to Reference the Value of end() 
The iterator returned by the end function represents a position that is just past the 
last item in the list. It does not reference an object. If you attempt to dereference an 
iterator that is equal to this value, the results are undefined. This means that your 
program may appear to work, but in reality there is a hidden defect. Some C++ library 
implementations test for the validity of an iterator, but such verification is not 
required by the C++ standard. When we show how to implement the list iterator, 
we will show an implementation that performs this validation.

prefix和postfix
prefix直接加 postfix 先保存当前值 再加
前者更有效率
 
SYNTAX 
Accessing a Type Defined Inside a Template Class from Within a Template Class
FORM: 
typename template-class::the-type-name 
EXAMPLE: 
typename std::list<Item_Type>::const_iterator 
MEANING: 
The identifier the-type-name is the name of a type and not the name of a data field or member function. 
Under some circumstances within a template class or function, the compiler cannot tell whether a 
reference to another template class identifier is a type name or an identifier that names a data field or function. 
Placing the keyword typename in front of such references resolves the ambiguity. Even where there is no ambiguity, 
the standard requires you to use the keyword typename. On the other hand, outside of template classes and 
functions there is no potential ambiguity, so the use of typename is illegal.

PITFALL 
Misusing typename 
If you fail to use the keyword typename where it is required, you may get a warning or error message. 
The g++ compiler, for example, gives the message: 
warning: 'typename KW::list<Item_Type>::const_iterator is implicitly a typename 
warning: implicit typename is deprecated, please see the documentation for details 
Different compilers will have different error messages and may not issue a message under the same circumstances. 
On the other hand, if you use the keyword typename outside of a template class or function, you will 
get an error message.

PITFALL 
Failure to Use const_iterator to Reference a const List 
If we declared iter to be an iterator instead of a const_iterator, the function print_list would fail to 
compile, with an error message equivalent to: 
test_list.cpp: In function 'void print_list(const KW::list<int>&)': test_list.cpp:122: 
conversion from 'KW::list<int>::const_iterator' to non-scalar type 'KW::list<int>::iterator' requested 
This is the error message produced by the g++ compiler. Other C++ compilers will produce similar error messages. 
If we were allowed to use an iterator (instead of a const_iterator), we could then use it to change the 
contents of the list that was passed as a parameter to the function print_list.

PROGRAM STYLE 
Delegation Pattern 
Delegation is a programming technique or OOD pattern that is used frequently. Through delegation, 
you can easily implement a new class that has an existing class as a component. 
If the new class and old class have similar functions, then you can implement the new class functions 
by delegation to the functions in the existing class.

SYNTAX 
Defining an Alias for a Type
FORM: 
typedef original-type-name new-type-name; 
EXAMPLE: 
typedef typename std::list<Item_Type>::const_iterator const_iterator; 
typedef Item_Type item_type; 
MEANING: 
The identifier new-type-name may be used as a type name, and it will have the same meaning as original-type-name. 
In many compilers this is done by a straightforward text substitution. Thus error messages that make 
reference to new-type-name will be shown using original-type-name.

SYNTAX 
Defining a Template Function
FORM: 
template<typename T1, ... , typename Tn> 
return-type function-name(Ti, ... , Tj) 
EXAMPLES: 
template<typename Item_Type> list<Item_Type>::iterator find(list<Item_Type>& a_list, const Item_Type& target)
template<typename iterator, typename Item_Type> iterator find(iterator first, iterator last, const Item_Type& target) 
MEANING: 
The function function-name takes parameters of the template types T1 through Tn. The template parameter types 
are listed following the keyword template and must also be included in the function signature. 
The order of the parameters in the function signature does not need to be the same as they are 
following the keyword template, but each parameter type must be used at least once.

SYNTAX 
Calling a Template Function 
FORM: 
function-name(actual-parameter-list) 
EXAMPLE: 
find(list_1.begin(), list_1.end(), 10) 
MEANING: 
The types of the actual parameters are matched to the template type parameters. The template function is 
then instantiated with the parameter matching specified in the call. 
In our example the type of the actual argument list_1.begin() is a list<int>::iterator, 
as is the type of the second argument list_1.end(). The third parameter has the type int. 
Therefore, the template parameter Iterator is bound to list<int>::iterator, 
and the template parameter Item_Type is bound to int. The matching of the parameter types to template parameters 
is done at compile time. This is a very powerful feature of C++ that is used by the STL to do some fairly 
amazing things.

SYNTAX 
Declaring inline Functions
FORM: 
inline function-declaration {body} 
EXAMPLE: 
inline void swap(vector<Item_Type>& x, vector<Item_Type>& y) { x.swap(y); } 
MEANING: 
The compiler replaces a call to that function with the code contained in the function body. 
Such code executes faster. Since the compiler must be aware of the code to be generated, 
inline function definitions must be placed in header files.

PROGRAM STYLE 
Specializing the swap Function 
Any class that dynamically allocates memory, or contains objects with dynamically 
allocated memory—a vector, for example—should provide a swap member function and 
a specialization for the swap function. The swap member function should be written 
as follows: 
void swap(class_name& other) { 
// Use the std::swap function to swap each data field. 
// . . . 
} 
The specialization should be defined in the declaration file (the .h file) and should be 
written as follows: 
inline void swap(class-name& x, class-name& y) { x.swap(y); }

PROGRAM STYLE 
Using an Iterator as a Loop Control Variable 
The string class provides two ways to access individual characters: using an iterator 
or using an index. Therefore, you could write the loop in function fill_stack as follows: 
for (string::const_iterator itr = input_string.begin(); itr != input_string.end(); ++itr) { 
char_stack.push(*itr); 
} 
This is because the string class provides all of the functions required for a sequential 
container. Using an iterator instead of an index is more general and would allow you to 
replace the string input parameter with a list parameter.

PITFALL 
Attempting to Pop an Empty Stack 
If you attempt to reference the top of or to pop an empty stack, your program will probably 
halt and report a run-time error. The nature of the error message will depend on the compiler 
and operating system. Under Linux you will probably get the message segmentation fault, 
and under Windows you will get an error dialog box reporting an illegal attempt to 
access memory. It is also possible that no error is reported at all. You can guard 
against this error by testing for a nonempty stack before calling top or pop.

PROGRAM STYLE 
Declaring Constants 
We declared OPEN and CLOSE as global constants instead of declaring them locally in 
the functions where they are used (is_open and is_close). There are two reasons for 
this. First, it is a more efficient use of memory to declare them as constants 
instead of having to allocate storage for these constants each time the function is 
called. Also, if a new kind of parenthesis is introduced, it is easier to 
locate and update the class constants instead of having to find 
their declarations inside a function. However, relying on global constants makes 
functions less portable (less easy to drop in elsewhere), 
so this dependence should be mentioned in the function’s comment header.

有些类中的同一操作，参数分为两种，一种是const，一种是非const，这主要用作左操作符和右操作符。

PROGRAM STYLE 
Reason for Including File Stack.tc in File stack.h 
In earlier programming, we were able to write the definition file (extension .h) for a 
class and its implementation file (extension .cpp) as separate files, and we would 
include the .h file at the beginning of the .cpp file. C++ does not permit this for 
template classes, however, because for each instantiation of a template class in 
a client program the compiler needs to see the template to create an instantiation for 
those member functions that are used in the current instantiation. Therefore, 
we have placed the implementation in a separate file and given it the extension 
.tc to specify template implementation files.  The .tc file, while not a typical header 
file, is still an included file, so it should not contain using directives or 
using statements. An alternate approach would be to replace each function declaration 
in file stack.h with its actual definition (see Listing 5.6). 
This is simpler for the case where we only have a single implementation of an ADT; 
however, it does not provide a separate interface file and therefore makes it a bit more 
difficult to provide different implementations of the ADT.
不能在头文件中使用using！
因为.h文件是覆盖到总文件中的，因此using就被引入了整个文件，进而使得整体文件中莫名其妙地引入了一个using，
造成命名空间污染。

ADT可以使用不同的方式来实现，.tc文件可以方便地调整不同的实现方式

PROGRAM STYLE 
Creating Your Own Exception Class 
The program would work just the same if we did not bother to declare the Syntax_Error class and just threw a 
std::exception object each time an error occurred. However, we feel that this approach gives the user a more meaningful description of 
the cause of an error. Also, if other errors are possible in a client of this class, any Syntax_Error exception can be caught 
and handled in a separate catch clause.

PROGRAM STYLE 
Using #ifdef, #else to Select a Stack Implementation 
We select the stack implementation and define data field operator_stack using 
the #ifdef, #else compiler directive. This allows us to select either the stack 
implementation in the user namespace KW or the stack implementation in the standard 
namespace depending on the switch USEKW. If the switch USEKW is defined, 
the preprocessor inserts the following code: 
#include "stack.h" 
... 
KW::stack<char> operator_stack; 
If the switch USEKW is not defined, the preprocessor inserts the following code instead: 
#include <stack> 
... 
std::stack<char> operator_stack; 
We can define this switch when we compile the program using the -D compiler directive. 
For example, to use the KW implementation using the gcc compiler, we would compile 
using the following command: 
g++ -DUSEKW -o Infix_To_Postfix Infix_To_Postfix.cpp Test_Infix_To_Postfix.cpp 
The -DUSEKW defines the macro symbol USEKW. The -o specifies the name given to the 
executable file (Infix_To_Postfix). If this is omitted the executable file 
is given the strange name a.out. Without the –DUSEKW, the switch USEKW would not be 
defined, and the standard stack would be used. The various integrated development 
environments also provide a way to set this compiler directive.

动态分配很多小对象，是一件很费空间的事情。

对于大规模的大对象集合，可以使用deque，因为deque的实现，不像vector，vector是一个数组，每个数组
包含对象。而deque使用的是多个数组结合的方式，第一个数组包含的是指向数组的指针，指针指向的数组包含了
对象。为什么要用这种表达方式？

 For large collections of large objects, the deque can be used instead of the vector to 
 minimize space overhead and the cost of reallocation.

 PITFALL 
 Infinite Recursion and Stack Overflow 
 If you call function factorial with a negative argument, you will see that 
 the recursion does not terminate. It will continue forever, because the 
 stopping case, n equals 0, can never be reached, as n gets more negative 
 with each call. For example, if the original value of n is –4, you will 
 make function calls factorial(–5), factorial(–6), factorial(–7), and so on. 
 You should make sure that your recursive functions are constructed so that 
 a stopping case is always reached. One way to prevent the infinite recursion 
 in this case would be to change the terminating condition to n <= 0. 
 However, this would incorrectly return a value of 1 for n! if n 
 is negative. A better solution would be to throw an invalid_argument 
 exception if n is negative. If your program does not terminate properly, 
 you may see an extremely long display on the console (if the console is 
 being used to display its results). However, if the recursive 
 call occurs before any output is displayed, you will see no 
 output. Eventually you will get a run-time error because there is no more 
 memory available for your program to execute any more function calls.

explicit关键字是用来修饰类的构造函数，表明该构造函数是显式的。
如果c++类的构造函数有一个参数，那么在编译的时候就会有一个缺省的转换操作，
将该构造对应数据类型的数据转换成该类对象
比如：
class MyClass
{
    public:
        MyClass(int num);
}

MyClass obj = 10;
//equal to MyClass temp(10); MyClass obj = temp;

这种就是所谓的隐式转换。

比如我们声明：
class string
{
    String(int n);
    String(const char *p);
}

String s2(10);
String s3 = String(10);
这样写都是没有问题的

但是这样写就有问题了
Stirng s4 = 10;//equal to String s4(10);
String s5 = 'a';//equal to String s5(int('a'));

为了避免这种隐式转换，我们就需要声明explicit

操作符重载
操作符可以重载为类成员函数（左操作数可以隐式指定）
也可以重载为非类成员函数（全局函数）（左操作数必须显示指定）

一元操作符可以是不带参数的成员函数 或者是 带一个参数的非成员函数

二元操作符可以是带一个参数的成员函数 或者是 带两个参数的非成员函数

operator=, operator[], operator(), operator->只能定义成为成员函数

operator->的返回值必须是一个指针或者是能使用->的对象

重载operator++ 和 operator-- 时 带一个int参数表示后缀操作符，不带参数表示前缀操作符

要使用inline关键字

对于同一程序的不同文件，如果inline函数出现的话，其定义必须相同

关键字inline必须与函数定义体放在一起才能使得函数成为内联，仅将inline放在函数声明
前面不起任何作用。

内联函数在编译时直接将函数嵌入到调用程序的主体，省去了调用/返回指令，这样在运行时速度更快。
通过避免被调用的开销来提高执行效率。

当定义一个内联函数时，需要在函数定义前加上inline关键字，并且将定义放入头文件。

内联是以代码膨胀（复制）为代价的，省去了函数调用的开销，从而提高函数的执行效率。
如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率提高就会少得多。
同时每一处内联函数的调用都要复制代码，将使得程序的总代码量增大，消耗更多的内存空间。

因此以下几种情况不适合使用内联

1、函数体内的代码过长，使用内联将导致内存消耗代价较高。

2、如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。

定义在类声明之中的成员函数将自动地成为内联函数。

inline不应该出现在函数的声明中

类的构造函数和析构函数也不要随便定义放在类声明中。

PITFALL 
Failure to Qualify a Template Base Class Member Name 
If you fail to qualify a template base class member name within a template derived class, you may get an error message. 
However, if this name happens to be defined outside the class, you will not get an error, but your program will not execute as expected. 
This is because the other name will be used. For example, if there was a global variable root, and 
we omitted this-> from the call to find, then find would start the search using the contents of this global variable.

基类和派生类

class Base
{
    public:
        Base(){};
        Base(int m){};
        ~Base(){};
}

class Derived: public Base
{
    private:
        int n;
    public:
        Derived(int m):n(m){}
        ~Derived(){};
}
如果声明Base(){}，那么声明Derived类型变量的时候，会默认调用Base()构造函数
如果不声明Base(){}，同时不是Derived(int m):n(m) Base(m){}，那么就会报错
派生类的析构函数，会默认调用基类的析构函数

公用派生类拥有基类的全部功能
由于派生类中包含从基类中继承的成员，因此可以将派生类的值赋给基类对象。

1、派生类对象可以向基类对象赋值

A a1;//基类
B b1;//公用派生类
a1 = b1;

但是此时a1不能访问派生类中的成员。

2、派生类对象可以替代基类对象 向基类对象的引用进行赋值或者初始化
A a1;
B b1;
A& r = a1;
r = b1;
或者
A& r = b1;

注意此时r并不是b1的别名，也不和b1共享同一段存储单元 它只是b1中基类部分的别名

3、
fun: void fun(A& r)
{
    cout<<r.num<<endl;
}
这时可以使用fun(b1);其中b1是派生类B类型
这里也只能输出派生类中基类成员的值

4、派生类对象的地址可以赋值给指向基类对象的指针变量 也就是说 指向基类对象的指针变量也可以指向派生类对象

但是通过指向基类对象的指针，只能访问派生类中的基类成员，而不能访问派生类增加的成员。

有的时候，多继承很容易引起冲突
比如A->B,A->C,同时D多继承B和C
那么在这个派生类中保留间接基类的多份同名成员，这样会占用较多的存储空间，还容易产生命名冲突。
为了解决这个问题，引入了虚基类。
class A{}
class C: virtual public A{}
这样就使得在派生类中只保留间接基类的一份成员了。
比如B从A中继承了变量a，C也从A中继承了变量a，这是D继承B和C就会有两个变量a，发生冲突。通过虚继承，就只会保留一个a的拷贝。
但是虚继承中，为了避免矛盾，在最后的派生类中，不仅要负责对其直接继承的基类进行初始化，同时还要负责对虚基类的初始化。
class D: virtual public B, virtual public C
{
    private:
        int d;
    public:
        D(int a, int b, int c, int d): A(a), B(a, b), C(a, c), d(d){}
}

PROGRAM STYLE 
A Generic Huffman_Tree Class 
We chose to implement a nongeneric Huffman_Tree class to simplify the coding. However, it may be desirable to build a Huffman tree 
for storing strings (for example, to encode words in a document instead of the individual letters) or for storing groups of pixels 
in an image file. We can do this by making the Huffman_Tree, Huff_Data and Compare_Huffman_Tree classes template classes. 
The template parameter would represent the type of the symbols. The implementation of the member functions would need to be 
included in the .h file that contains the class definitions.

SYNTAX 
const_cast 
FORM: 
const_cast<target_type>(value) 
EXAMPLE: 
const_cast(Entry_Type&)(*(ret.first)) 
MEANING: 
If the type of value was a const reference type (or const pointer type), it is converted to target_type, where target_type is the 
corresponding non-const reference
(or pointer) type. You must be careful using this construct, because it allows you to violate the protection provided by the language. For example, a const_cast could be used to change the key of the item stored in either a set or a map. The set and map use binary search trees, so changing a value could make the tree cease to be a binary search tree. The insert, erase, and find operations would no longer work. In this case we knew that the Value_Type part of the Entry_Type could be changed without harming the structure of the_set.

Function Call Operator
When a user-defined class overloads the function call operator, operator(), it becomes a FunctionObject Type.
Many standard algorithms, from std::sort to std::accumulate accept objects of such types to customize behavior.
There are no particular notable canonical forms of operator(), but to illustrate the usage
struct Sum
{
    int sum;
    Sum() : sum(0) {}
    void operator()(int n) {sum += n};
};

Sum s = std:for_each(v.begin(), v.end, Sum())    

PITFALL 
Side Effect of Retrieving a Missing Key 
In function build_index, the statement index[word].push_back(line_num); uses the expression index[word] to retrieve the value (a list) 
associated with string word. If this is the first occurrence of word, a side effect of the retrieval is that an empty list is 
inserted in index as the value associated with word, and the line number is inserted into this list. This is just what we want to happen. 
However, there are other situations when we don’t want to insert a new entry into the map if the key is missing. 
In these cases, we should use find to perform the retrieval, as in the following fragment. 
const_iterator itr_word = index.find(word); 
if (itr_word != index.end()) 
cout << "first occurrence is on line # " << itr_word->second.front()) << endl; 
else 
cout << word << " is not in the index\n" 
The if statement displays either the line number of the first occurrence of word (itr_word->second.front()) or 
a message that word is not present.

PITFALL 
Not Defining the Compare Function as a Total Ordering Relationship 
Suppose we defined Compare_Person as follows: 
struct Compare_Person 
{ 
bool operator()(const Person& p1, const Person& p2) 
{ 
if (p1.family_name < p2.family_name) 
return true; 
else 
return p1.given_name < p2.given_name; 
} 
} 
Then “Jones, Tom” (family_name is "Jones", given_name is "Tom") would be less than “Smith, John” 
(family_name is "Smith", given_name is "John") as expected, but “Smith, John” would also be less than “Jones, Tom” 
(since "John" < "Tom"). A map with this as a Compare function will give very strange results.

DESIGN CONCEPT 
Proposed Standard Hash Function Class 
Although hash tables were not included in the original C++ standard, there has long been a desire for their inclusion. 
Currently the C++ standard is undergoing revision, and hash tables are one of the proposed additions. 
One issue with including hash tables is how to designate the hash function. The proposed solution is to define a 
template function class hash. This class would be specialized for the primitive types and other librarydefined types such as string. 
The type hash<type> would then designate the hash function class for the type type, and hash<type>() would designate the function object. 
The expression hash<type>()(key) would then evaluate the function for the value key.

SYNTAX 
Initializing Static Data Members of a Template Class 
FORM: 
template<template parameter declarations> 
type class_name<template parameters>::member_name = value; 
EXAMPLE: 
template<typename Key_Type, typename Value_Type> 
typename hash_map<Key_Type, Value_Type>::Entry_Type 
hash_map<Key_Type, Value_Type>::dummy = 
std::pair<const Key_Type, Value_Type>(Key_Type(), Value_Type()); 
MEANING: 
Memory is allocated for the static object class_name::member_name, and 
it is initialized to the specified value. This can become quite complicated, 
especially where the type of the data member is also defined within 
the template class. In this example 
typename hash_map<Key_Type, Value_Type>::Entry_Type is the type of 
the data field, hash_map is the class, dummy is the member name, 
and std::pair<const Key_Type, Value_Type>(Key_Type(), Value_Type()) 
is the value.

SYNTAX 
Constant Pointer Declaration 
FORM: 
type* const name; 
EXAMPLE: 
static Entry_Type* const DELETED; 
MEANING: 
By placing the const qualifier after the *, the identifier name 
is declared to be a constant pointer. That is the 
value of the pointer (the address of the location pointed to) remains 
constant. The value pointed to, however, is not declared to be a constant. 

PROGRAM STYLE 
Use of size_t versus int for Indexes 
Notice that we declared index to be of type size_t. This is an unsigned type, which is the type returned by the vector size() function. The C++ compiler defines this type as an unsigned integer type that has sufficient range to represent all index values. (The specific type depends on the architecture of the computer on which the program is to be executed.) By using an unsigned value we are sure that the result of the modulo operator (%) is in the range 0 to the_table.size() - 1. If we defined index and hash_fcn to return int values, then the result of hash_fcn could be negative and the result of the modulo operator could also be negative.

PITFALL 
Integer Division for Calculating Load Factor 
Before calling function rehash, function insert calculates the load factor 
by dividing the number of filled slots by the table size. 
This is a simple computation, but if you forget to convert the 
numerator or denominator to double, the load factor will be zero 
(because of integer division), and the table will not be expanded. 
This will slow down the performance of the table when it becomes 
nearly full, and it will cause an infinite loop (in function locate) 
when the table is completely filled.

为什么copy constructor assignment operator 和 destructor要同时声明？
因为它们都动态分配内存，因此要同时声明，它们之间也互相帮助。
这样做的目的也是为了深拷贝，而不是浅拷贝。
浅拷贝直接把指针复制过去了，这样会出现错误，深拷贝重新申请资源。

DESIGN CONCEPT 
Iterator Traits 
You may wonder how the iterator_traits determines the type of the object 
that the iterator references. Basically, the iterator provides this 
information. In Chapter 4 we described the list container and showed 
how to implement its iterator. To keep the explanation simple, 
we omitted several details, one of which we will now explain. 
Each container class is required to provide certain typedefs, 
including one named value_type. Thus, our list class should have had the 
following declaration: 
template<typename Item_Type> 
class list { 
public: 
typedef Item_Type value_type; 
... 
Likewise, the iterator class (defined within the list class) should have 
the declaration: 
class iterator { 
typedef typename list<Item_Type>::value_type value_type; 
The iterator_traits class is then defined as follows: 
template<typename Iterator> 
struct iterator_traits { 
typedef typename Iterator::value_type value_type; 
... 
}; 
When the compiler sees the function call: sort(v.begin(), v.end()) 
it determines that the type of the expressions v.begin() and v.end() 
is vector<int>::iterator and thus the template parameter Iterator 
is bound to this type. Therefore the expression 
typename iterator_traits<Iterator>::value_type 
becomes 
typename iterator_traits<vector<int>::iterator>::value_type 
Since ordinary pointers can be used as iterators, we need to add an 
additional specialization for iterator_traits. 
template<typename T> 
struct iterator_traits<T*> { 
typedef T value_type; 
... 
}; 
Now in the function call sort(a, a + 20) where a is an array of int, 
the parameter type is int*, and the template parameter Iterator is 
bound to this type. Thus the expression 
typename iterator_traits<Iterator>::value_type
becomes 
typename iterator_traits<int*>::value_type 
The compiler then associates T with int, so that the declaration 
typedef T value_type; 
becomes 
typedef int value_type;

PROGRAM STYLE
By using the postincrement operator on the iterators, 
you can copy the current item from one input sequence, append it to 
the end of the output sequence, and then increment the iterators to 
that input sequence and the output sequence in one statement. 
The statement: 
*out++ = *left++; 
is equivalent to the following three statements, 
executed in the order shown: 
*out = *left; 
++out; 
++left; 
Both the single statement and the group of three statements 
maintain the invariant that the iterator left references 
the next item to insert from the left input sequence.

PITFALL 
Invalid Pointer Arithmetic 
In the statement 
RI parent = first + (child – first - 1) / 2;  // Find parent. 
the expression part is algebraically equivalent to (first + child – 1)/2. 
However, using this expression would cause a syntax error indicating 
invalid pointer addition. You can't add pointers, 
because pointers represent addresses and the result of adding two 
addresses is not logically meaningful. However, 
you can subtract two pointers, or you can add or subtract a constant 
(an offset ) to a pointer. An analogy would be comparing times. 
If you arrived at place A at 4 PM and at place B at 6 PM, 
you could subtract the two times to determine that it took you 2 hours to go 
from place A to place B. But adding the two times would not be meaningful.

PITFALL 
Falling Off Either End of the Array 
A common problem when incrementing up or down during the partition process 
is falling off either end of the array. We used the condition 
((up != last - 1) && !(*first < *up)) 
to keep up from falling off the right end of the array. 
Self-Check Exercise 3 asks why we don’t need to write similar code to 
avoid falling off the left end of the array.

 traits是干什么的？
 当函数、类或者一些封装的通用算中的某些部分会因为数据类型的不同而导致处理或者逻辑不通（而我们又不希望因为
 数据类型的差异而修改算法本身的封装时），traits就会是一种很好的解决方案。
 通过定义traits，就可以保证在不同参数的情况下，可以分情况处理，而不用修改算法本身。

SYNTAX 
Declaring a Virtual Base Class 
FORM: 
class derived-class : public virtual base-class { ... };
EXAMPLE: 
class Student : public virtual Person { ... }; 
class Employee : public virtual Person { ... }; 
MEANING: 
If a class is derived from two other classes that share a common virtual base class, 
then only one instance of the base class will be included in the derived class. 
To ensure that there is no inconsistency in the initialization process, 
the constructor(s) for the virtual base class(es) is(are) 
invoked before the constructors of the other base classes. 
Therefore, if initialization of a virtual base class is required, 
it must be specified by the constructor of the final derived class.

PITFALL 
Failure to Initialize a virtual Base Class 
If a virtual base class needs to be initialized, and a derived class that multiply 
inherits it does not explicitly initialize it, it will remain uninitialized. 
For example, if our Student_Worker class had the following constructor: 
Student_Worker(const std::string& the_name, 
Address* the_address, double the_rate, const std::string& the_major) 
: Employee(the_name, the_address, the_rate) , Student(the_name, the_address, the_major) {} 
it would invoke the Employee and Student constructors. These constructors contain 
calls to the three-argument Person constructor. However, since Person is a virtual base 
class, the no-argument constructor for Person is invoked before 
the constructors for Employee and Student. When the Employee and Student constructors 
are invoked, their calls to the three-argument Person constructor are not performed.

因此也要显示地初始化Person无参数类

