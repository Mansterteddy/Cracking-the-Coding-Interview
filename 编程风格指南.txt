SYNTAX 
The define Preprocessor Directive
FORM: 
#define macro-name macro-definition 
#define macro-name(parameter-list) macro-definition 
EXAMPLES: 
#define NULL 0 
#define MAX(x, y) ((x) > (y) ? (x) : (y)) 
MEANING: Subsequent to the definition, whenever the symbol macro-name 
is encountered, the preprocessor will replace it with the macro-definition. 
The macro-definition begins with the first nonspace character after the 
macro-name and ends with the last nonspace character on the same line as the 
#define directive. If there are parameters following the macro-name 
(for example, x and y in MAX(x, y)), they are replaced in the 
macro-definition with the corresponding actual arguments.

SYNTAX 
The #ifdef, #ifndef, #else, and #endif Preprocessor Directives 
FORM: 
#ifdef macro-name 
code to be included if macro-name is defined 
#else code to be included if macro-name is not defined 
#endif 
or 
#ifndef macro-name 
code to be included if macro-name is not defined 
#else 
code to be included if macro-name is defined 
#endif 
The #else is optional, but there must be an #endif to correspond to the #ifdef or #ifndef. 
EXAMPLE: 
#ifdef __cplusplus 
extern "C" { ... } 
#endif 
MEANING: 
Indicates what to include if the macro-name is defined or not defined. 
If the macro-name is defined, include all the lines of code between the 
#ifdef and the #else (if present), or between the #ifdef and the #endif 
if there is no #else. If the macro-name is not defined, include all 
the lines between the #else and the #endif (if any). 
The opposite happens if the first line begins with #ifndef.

PROGRAM STYLE 
Using Preprocessor Directives to Prevent Multiple Inclusion of an Include File 
We use include files to package function and class declarations. 
It is possible that a function or class uses other functions or classes 
that are defined in other include files. However, it is an error if 
the same function declaration or class declaration is presented to the 
compiler more than once. When you write an include file, you do not know 
when it is going to be used or by what programs, so each include file 
should be guarded using preprocessor directives to ensure that it is 
included only one time. The way this is done is to begin the include file 
with two directives of the form: #ifndef unique-name #define unique-name 
where unique-name, as the place holder implies, is a unique name. 
Generally the file name is converted to uppercase, the period that separates
the name from the extension is replaced by an underscore, and a trailing 
underscore is added. Thus the include file myfile.h would use MYFILE_H_ as 
the unique name. You may see other conventions. The last line of the 
include file is an #endif directive. The first time the preprocessor sees 
the #ifndef directive, the unique-name will not be defined. 
Thus the lines that follow will be processed by the preprocessor and passed 
on to the compiler. The #define directive will define unique-name 
so that the next time the preprocessor sees the include file, 
the #ifndef will be false and the file will be skipped. Note again that
the last line of the file should be #endif.

PROGRAM STYLE 
Braces and Indentation in Control Statements C++ programmers often place 
the opening brace { on the same line as the control statement header. 
The closing brace } aligns with the first word in the control statement header.
We will always indent the statements inside a control structure to clarify 
the meaning of the control statement. Although we write the symbols } 
else { on one line, another popular style convention is to place the word else 
under the symbol } and aligned with if: 
if (next_int % 2 == 0) { 
    sum += next_int; 
} 
else { 
prod *= next_int; 
} 
Some programmers omit the braces when a true task or false task or a loop 
body consists of a single statement. Others prefer to include them always, 
both for clarity and because having the braces will permit them to insert 
additional statements later if needed.

PITFALL 
Omitting Braces Around a Compound Statement 
The braces in the preceding example delimit compound statements. 
Each compound statement consists of two statements. 
If you omit a brace, you will get the syntax error 'else' without 'if'. 

PROGRAM STYLE 
Writing if Statements with Multiple Alternatives 
C++ programmers often write nested if statements like those in the 
preceding example without indenting each nested if. The following 
multiple-alternative decision has the same meaning but is easier to write 
and read. 
if (operator == '+') { 
    result = x + y; 
    add_op++; 
} else if (operator == '-') { 
    result = x - y; 
    subtract_op++; 
} else if (operator == '*') { 
    result = x * y; 
    multiply_op++; 
} else if (operator == '/') { 
    result = x / y; 
    divide_op++; 
}


PROGRAM STYLE 
C++ Convention for Identifiers 
Many C++ programmers use lowercase words or phrases for variable names. 
Words are separated using the underscore character. 
For classes it is common to use a word or words that begin with an initial 
uppercase letter. However, the C++ standard uses lowercase for both 
variable and class names. Identifiers that are in all uppercase are 
used for macros. Another convention that is becoming popular is 
“camel notation” for variable names. All letters are in lowercase except for 
identifiers that are made up of more than one word. 
The first letter of each word, starting with the second word, 
is in uppercase (for example, thisLongIdentifier). 
Camel notation gets its name from the appearance of the identifier, 
with the uppercase letters in the interior forming “humps.”

PITFALL 
Using Increment and Decrement in Expressions with Other Operators 
In the preceding example, the increment operator is used with the 
assignment operator in the same statement. Similarly, the expression 
x * i++ uses the multiplication and postfix increment operators. 
In this expression, the variable i is evaluated and then incremented. 
When the prefix form is used in an expression (for example, x * ++i), 
the variable i is incremented before it is evaluated. 
However, you should avoid writing expressions like these, 
which could easily be interpreted incorrectly by the human reader.

SYNTAX 
Object Declaration
FORM: 
type-name name; 
type-name name = initial-value; 
type-name name(parameter-list); 
EXAMPLE: 
int i; 
string s = "hello"; 
double x = 5.5; 
double y(6.7); 
point p(x, y);
MEANING: 
The specified name is declared to reference an object of the 
specified type-name. Memory for this object is allocated and initialized to 
the specified value. In the first example, the name i refers to an int object,
with an unspecified initial value. In the third and fourth examples the 
names x and y refer to double objects with the initial values 5.5 and 6.7, 
respectively. Note that the two forms used to initialize x and y are 
equivalent. In the final example p refers to an object of type point 
(a class type) with the initial value (x, y). 

SYNTAX 
Pointer Declaration
FORM: 
type-name* pointer-variable; 
type-name* pointer-variable = &object; 
EXAMPLE: 
int* k; 
int* k = &count; 
MEANING: 
The value of the pointer-variable will be a memory address. 
If the initial value begins with the prefix &, as in &object, 
the pointer-variable is initialized to the memory address of object.

SYNTAX 
Address-Of Operator &
FORM: &object 
EXAMPLE: &k; 
MEANING: Gives the address (memory location) of object.

SYNTAX 
Dereferencing Operator * 
FORM: 
*pointer-variable 
EXAMPLE: 
*px; 
MEANING: 
Gives the object referenced by pointer px. The data associated with this 
object value can be accessed or changed. For example, if px is type double*,
the statement *px = 25.0; stores 25.0 in the object referenced by px. 
The statement *px = *px + 2.5; changes the value of this object to 27.5.

PROGRAM STYLE 
Use of T* v versus T *v to Declare a Pointer Variable 
Programmers generally use one of the following statements to declare a pointer
variable. double* px; double *px; The argument in favor of the first form 
is that it clearly states that px is of type double* (that is, 
a pointer to double). The second form states that the expression *px is 
of type double (and therefore px is of type pointer to double). 
The second form is technically more correct, since this is how the compiler 
interprets it. Which one you use is a matter of personal taste as long as you 
declare each variable individually. 

PITFALL 
Declaring Multiple Pointer Variables in One Declaration 
You may also declare multiple variables of the same type in one 
declaration statement. In that case you must remember that the compiler 
binds the * to the variable and not the type. Thus the declaration 
double* px, py; declares that px is a pointer to double, but that py is a 
double! To declare both px and py to be pointers we need to use the 
declaration double *px, *py;

PROGRAM STYLE 
Use of NULL versus 0 The choice of using NULL or 0 to represent the null 
pointer is the subject of much discussion among C++ programmers. 
The C++ standards committee is currently working on a revision to 
the C++ standard. One of the proposed changes is to define a true null 
pointer constant as a new reserved word in the language. 

SYNTAX 
The new Operator 
FORM: 
new type-name 
new type-name(initial-value) 
new class-name(parameters) 
EXAMPLE: 
new double; 
new double(1.23456); 
new std::string(line, 5, 10) 
MEANING: 
Memory is allocated for an object of type type-name. If an 
initial-value or list of parameters is provided, those values are 
placed in the new object. (In the case of an object of class type, 
these actions are carried out by a call to the constructor for the class 
that takes these parameters. Constructors will be discussed in Chapter 1.) 
A pointer to the created object is returned. The first of the foregoing 
examples creates a double object and returns a pointer to it. 
The second example creates a double object, initializes its value to 1.23456, 
and returns a pointer to it. The third example creates a new string object
and initializes it to the substring of the string line that begins at the 
fifth character and has a length of 10 characters.

SYNTAX 
The delete Operator 
FORM: 
delete pointer-variable; 
EXAMPLE: 
delete px; 
MEANING: 
The memory occupied by the object pointed to by px is returned to the free 
memory pool. (If the object is of class type, 
the destructor function for the class is called first; 
destructors will be discussed in Chapter 1.) 
Note that the pointer variable must point to an object that was created 
via the new operator.

PITFALL 
Out-of-Bounds Subscripts 
C++ allows you to use an array subscript that is outside of the array bounds. 
For example, if you attempt to reference scores[5], 
a C or C++ compiler would access the first memory cell following the array scores. 
This is considered an error, but it is not detected by the run-time system 
and will probably lead to another error that will be detected further 
down the road (before it does too much damage, you hope).

SYNTAX 
The new[] Operator
FORM: 
new type-name[expression] 
EXAMPLE: 
new string[n] 
MEANING: 
Space is allocated for an array of type-name objects of length expression.
A pointer to the first element of this array is returned.

SYNTAX 
The delete[] Operator
FORM: 
delete[] pointer; 
EXAMPLE: 
delete[] students; 
MEANING: 
The dynamically allocated array whose first element is pointed to by pointer 
is deleted and returned to the free storage pool. Note that the array 
must have been allocated using the new[] operator. 

PROGRAM STYLE 
Use of at Versus the Subscript Operators 
If names is a string, you can reference the character at position index 
using either names.at(index) or names[index]. The use of at has the advantage 
that if the index is not valid, the program is aborted as a result of an exception 
being thrown. (Exceptions are discussed in Chapter 2.) However, despite this advantage,
C++ programmers generally prefer to use the latter form because it is simpler.

PITFALL
If you extract the last value on a data line using the extraction operator 
>> and then use getline, you will get a surprising result. 
There will still be an unprocessed \n character at the end of the data line, 
so the function call 
getline(cin, name, '\n'); 
would extract just the '\n' character, 
and an empty string would be stored in name. Consequently, you must first skip 
over the '\n' character (using function ignore) before calling getline to 
read the characters typed in on the next line. 
// Skip all characters through the first '\n' 
cin.ignore(numeric_limits<int>::max(), '\n');   
getline(cin, name, '\n'); 

SYNTAX 
Class Definition
FORM: 
class name { 
public: 
    member declarations 
private: 
    member declarations }; 
EXAMPLE: 
See Listing 1.1.
MEANING: 
The class name is defined to have the members listed. 
Members may be either data members (also called data fields), 
member functions (also called functions), or nested classes. 
Members that are declared following the access specifier 
public: are accessible by functions outside of the class, 
while those following the access specifier 
private: are accessible only by functions that are members of the class 
or are declared to be friends of the class. 
There may be multiple public and private regions, 
but generally all public members are declared together, 
followed by all private members. 
Also, declarations that precede the first access specifier are 
considered to be private.

SYNTAX 
Member Function Definition 
FORM: 
return-type class-name::function-name(parameter list) const(opt) { body } 
EXAMPLE: 
int Clock::get_hours() const { return hours; } 
MEANING: 
The function function-name that is a member of the class class-name is 
defined by the sequence of statements provided in the body. 
The declaration portion of the definition must be the same as that given 
in the class definition with respect to the return type, 
function name, types of parameters, and const specifier. 
The subscript opt following the const specifier indicates that it is optional. 
However, if it is present in the function declaration, it must also be 
present in the corresponding function definition. 
If these do not match, the compiler will report an error such as 
“function-name is not a member of class-name.” 

PROGRAM STYLE 
Explicit Namespace Qualification in Include Files 
You will notice that the include file included the standard headers 
<string> and <iostream>, but it did not contain a using directive 
such as using namespace std; Instead we specifically qualified the classes 
string and ostream with the prefix std::. This is because we do not know 
whether the client program will include the using directive. 
In Chapter 3 we will see reasons why this may not be desirable. 
It is considered good program style to always use explicit namespace 
qualification in header files.

SYNTAX 
Constructor Definition 
FORM: 
class-name(parameters) : initialization-expressions { body } 
EXAMPLES: 
Person(std::string first, std::string family, std::string ID, int birth) : given_name(first), family_name(family), ID_number(ID), birth_year(birth) { } 
Person() : given_name(""), family_name(""), ID_number(""), birth_year(1900) { } 
MEANING: 
A constructor has the same name as its class and has no return type. 
A constructor is called automatically when an object is created. 
Its purpose is to initialize the memory allocated to the object to initial 
values. Constructors may have parameters, and constructors having different 
parameter lists may be defined. The initialization-expressions are of the form 
data-field-name(initial-value). As the object is constructed, the named data 
fields are set to the given initial values. After the object is constructed, 
the body of the constructor is then executed. 

PROGRAM STYLE 
Use of Initialization Expressions in Constructors 
It is preferable to use initialization expressions to initialize data fields 
rather than using assignment statements in the body. 
Initialization expressions have the form data-member(initial-value-expression) 
An initialization expression such as given_name(first) is evaluated as 
the object is being constructed. If there is no initialization 
expression for a class data field, it may be initialized to a default value. 
The body is executed after the object is constructed. 
Thus, if you initialize a class data field in the body using an assignment 
statement 
given_name = first; 
you are effectively initializing it twice. 
While this does not matter for the built-in types 
because they have no default initialization, 
it is significant for class types, which may have 
several data fields of their own to initialize.

PROGRAM STYLE 
Inline Definition of Constructors, Accessors, and Modifiers 
It is a good programming practice to separate the declarations of the 
member functions from their definitions. The public portion of a class 
definition is its interface. This is how clients view the class. 
If the function definition is included in the class definition, 
the client programs include the function definition into their own code. 
Then, if we want to change a function’s implementation, we force the 
client programs to change. There are two reasons for making an 
exception for constructors, accessors, and modifiers. 
First of all, if a function definition is included in a class definition, 
the compiler treats this function as an inline function. 
That is, the compiler replaces a call to that function with the 
code contained in the function body. 
Such code executes faster. 
Second, constructors, accessors, and modifiers generally are very simple 
and are unlikely to change. Constructors generally consist only of 
initialization expressions; accessors generally consist of a return 
statement, and modifiers generally consist of a single assignment statement. 
Although we did not insert the accessor function definitions for class 
Clock in the public part of file Clock.h; it would have been permissible, 
and even desirable, to do this.

SYNTAX 
Operator Declaration 
FORM: 
return-type operator operator-symbol(parameter) const; 
EXAMPLES: 
bool operator==(const Person& per) const; 
bool operator!=(const Person& per) const; 
MEANING: 
The operator specified by operator-symbol is defined for this class. 
The left-hand operand is the current object; 
the right-hand operand is specified by parameter in the same way as a function 
parameter. If the word const appears at the end of the declaration, 
the left-hand operand is not changed by the operator.

PROGRAM STYLE
Returning a Boolean Value 
Some programmers unnecessarily write if statements to return a Boolean value. 
For example, instead of writing 
return ID_number == per.ID_number; 
they write 
if (ID_number == per.ID_number) 
    return true; 
else 
    return false; 
Resist this temptation. The return statement by itself returns 
the value of the if statement condition, which must be true or false. 
It does this in a clear and succinct manner using one line instead of four.

PITFALL
Referencing a Data Field or Parameter Hidden by a Local Declaration 
If you happen to declare a local variable (or parameter) with the same 
name as a data field, the local declaration hides the data field declaration, 
so the C++ compiler will translate the use of that name as 
meaning the local variable (or parameter), not the data field. 
So, if birth_year was also declared locally in class Person, 
the statement 
birth_year++; 
would increment the local variable, but the data field value would not change.

SYNTAX 
UML Syntax
In UML class diagrams, the + sign next to the function names indicate 
that these functions are public. The – sign next to the attributes name and 
number indicate that they are private. For the class Directory_Entry we 
show the types of the attributes, and the parameter types and 
return types of the member functions. 
Showing this information on the diagram is optional. 
We will generally show this information in separate tables such as 
Table 1.9. Appendix B provides a summary of UML.
 
PITFALL
Returning –1 (Failure) Before Examining All Array Elements 
A common logic error is to code the search loop for function find as follows: 
for (int i = 0; i < size; i++) { 
    if (the_directory[i].get_name() == name) { 
        return i; 
        } else { 
            return –1;  // Incorrect! – tests only one element. 
        } 
    } 
This loop incorrectly returns a result after testing just the first element.  

PITFALL 
Failure to Delete Dynamically Allocated Arrays 
If we do not return the storage allocated to the old array to the 
free-memory pool, this memory is lost. This is known as a memory-leak. 
Although modern computers seem to have infinite memory, 
there is in fact only a finite supply. Furthermore, 
programs that leak memory can impact other programs running on the same 
computer. A program that routinely leaks memory can eventually 
require you to reboot your computer.

PROGRAM STYLE 
Type Casting in C++ Versus C or Java 
In the type cast double(sum) the target data type is used as an operator, 
and the expression being cast is enclosed in parentheses. 
You could also use the C or Java form for type casting: 
(double) sum 
but it is not the preferred form.

PROGRAM STYLE 
Using a bool Result to Indicate Success or Failure 
What is gained by returning a bool value when we execute function 
set_element_of_x? The caller of the function can use this result to 
display an error message to the program user if desired. 
The following if statement applies function set_element_of_x to array x and 
writes an error message to stream cerr: 
if (!set_element_of_x(index, val)) 
    cerr << "*** ERROR – index value " << index << " is out of bounds. ***\n";

PITFALL 
Buffer Overruns Cause Security Holes 
Many of the security holes in programs are due to buffer overruns, 
which are a type of array-index-out-of-bounds error. 
A malicious program sends a large input stream to a program that does 
not check to see that the data fits into the array allocated to receive it. 
By modifying data outside of the allocated array, the malicious program 
is able to take over control of the target computer.

PROGRAM STYLE 
Initialize Pointers to NULL 
Although your program crashes if it attempts to dereference a null pointer, 
this is much better than having an error go unreported. C++ does not assign 
default values automatically to pointers when they are allocated. 
Until a pointer is assigned a value, it may point to anything at all. 
For this reason, it is a good practice to initialize a pointer to NULL 
when you first declare it. This way, if you attempt to dereference 
such a pointer before it is given an initial value, you will know about it.

SYNTAX 
The throw Statement
FORM: 
throw expression; 
EXAMPLES:  
throw "The value of index is out of range"; 
throw std::out_of_range("The value of index is out of range"); 
MEANING: 
The normal sequence of execution is interrupted, and control is 
transferred to the nearest exception handler whose parameter type matches 
the type of the expression. An exception handler is like a function, 
and the rules for matching an exception handler are the same as the 
rules for matching an overloaded function. If the current function 
body contains no such handler, then control is returned to the 
calling function, and a search is made from the point of the call. 
This process is repeated until the corresponding exception handler is 
found or until the main function is reached. 
If no exception handler is found, then the program terminates. 

SYNTAX The try Block
FORM: 
try { 
code that may throw an exception 
} catch (type-1 parameter-1) { 
statements to process type-1 
} catch (type-2 parameter-2) { 
statements to process type-2 
} ... catch (type-n parameter-n) 
statements to process type-n } 
EXAMPLE: 
try { 
val = get_element_of_x(10); 
} catch (std::out_of_range& ex) { 
cerr << "Out of range exception occurred\n"; 
cerr << ex.what() << endl; 
abort();    
// Exit with an error indication. } 
MEANING: 
The statements in the try block execute through to completion 
unless an exception is thrown. 
If there is an exception handler for the exception, 
its body executes to completion. 
If there is no exception handler that matches the exception, 
then the exception is passed up the call chain until 
either it is caught by some other function in the call chain 
or it is processed by the run-time library as an uncaught exception. 
If there are multiple catch blocks, 
they are checked in the order in which they appear. 
 
PITFALL 
Unreachable Exception Handler 
Note that only the first exception handler (catch block) that has an 
appropriate exception type executes. All other exception handlers are 
skipped. If an exception handler’s parameter type is derived from the class 
in an earlier exception handler, the earlier handler will match that type 
as well, and the later exception handler cannot execute. In this case 
the C++ compiler will issue a warning message. 
To correct this error, switch the order of the exception handlers 
so that the exception handler for the derived class type comes first. 

PROGRAM STYLE 
Using Exceptions to Enable Straightforward Code 
In computer languages that did not provide exceptions, 
programmers had to incorporate error-checking logic throughout 
their code to check for many possibilities, some of which were of 
low probability. The result was sometimes messy, as follows: 
Step A 
if (Step A successful) { 
Step B 
if (Step B successful) { 
Step C 
} else { 
Report error in Step B 
Clean up after Step A 
} 
} else { 
Report error in Step A 
} 
With exceptions this becomes much cleaner, as follows: 
try { 
Step A 
Step B 
Step C 
} catch (exception indicating Step B failed) { 
Report error in Step B 
Clean up after Step A 
} catch (exception indicating Step A failed) { 
Report error in Step A 
}

SYNTAX 
Assertion Statement
FORM: 
assert(expression); 
EXAMPLE: 
assert(x == 5); 
INTERPRETATION: 
If the expression evaluates to false, then the program writes an error 
message and aborts. The error message includes the expression that 
failed, the source file name, and the line number of the assertion statement.

SYNTAX 
Defining a Derived Class 
FORM: 
class derived-class : public base-class { ... } 
EXAMPLE: 
class Lap_Top : public Computer { ... } 
MEANING: 
The class derived-class inherits the member functions and data fields from the class 
base-class.

PITFALL 
Neglecting the Keyword public When Declaring a Derived Class 
If we omit the keyword public when we declare a derived class, we will declare a 
derived class with private inheritance. This means that the derived class will 
inherit the data fields and functions of the base class, but they will not be visible 
to client classes. Effectively, the derived class contains a private data field 
that contains a base-class object. This is another way to represent the has-a 
relationship.

PITFALL 
Not Defining the No-Parameter Constructor 
If no constructors are defined for a class, the no-parameter constructor for that class 
will be provided by default. However, if any constructors are defined, 
the no-parameter constructor must also be defined explicitly if it needs to be invoked. 
C++ does not provide it automatically in this case, because it may make no sense to 
create a new object of that type without providing initial data field values. 
(It was not defined in class Lap_Top or Computer because we want the client to specify 
some information about a Computer object when that object is created.) 
If the no-parameter constructor is defined in a derived class but is not defined 
in the base class, you will get a syntax error. For example, the g++ compiler 
displays an error such as no matching function call to class_name::class_name() 
You can also get this error if a derived-class constructor does not explicitly 
call a baseclass constructor. There will be an implicit call to the 
no-parameter base-class constructor, so it must be defined.

SYNTAX 
Calling Base-Class Functions
FORM: 
base-class::function-name() 
base-class::function-name(argument-list) 
EXAMPLE: 
Computer::to_string() 
MEANING: 
Using the prefix base-class:: in a call to function function-name 
calls the function with that name defined in the base class of 
the current class.

SYNTAX 
Declaring a Pointer Type
FORM: 
type-name* variable-name; 
EXAMPLE: 
Computer* the_computer; 
MEANING: 
The variable variable-name is declared to be of type 
pointer-to-type-name. As discussed in the C++ Primer, a pointer 
is an object that contains the address of another object. 
To reference the object pointed to by a pointer variable, 
use either the dereferencing operator * (for example, *the_computer) 
or the pointer class member access operator -> (for example, 
the_computer->). Pointers are initialized using either 
the address-of operator (&) or the new operator.

SYNTAX 
Creating New Objects Using the new Operator
FORM: 
new type-name; 
new type-name(argument-list); 
EXAMPLE: 
new Computer("Acme", "Intel P4 2.4", 512, 60); 
MEANING: 
Memory is dynamically allocated for a new object of type type-name 
and the constructor is then called to initialize the object. 
A pointer to the newly created object is the value of this 
expression. 

SYNTAX 
Accessing an Object Through a Pointer (the Dereferencing Operator *)
FORM: 
*pointer-variable 
EXAMPLE: 
*the_computer 
MEANING: 
The expression *pointer-variable is a reference to the object 
pointed to by pointer-variable. When used on the right-hand 
side of an assignment, it is the value of the object: 
Computer my_computer = *the_computer; 
Now, my_computer contains a copy of the Computer object 
referenced by the pointer variable the_computer. 
When used on the left-hand side of an assignment 
*the_computer = your_computer; 
then the referenced object is assigned the value of 
the right-hand side.

SYNTAX 
Accessing a Class Member through the Class Member Access Operator
FORM: 
pointer-variable->member-name 
EXAMPLE: 
the_computer->to_string(); 
my_ram = the_computer->ram_size; 
the_computer->ram_size = 1024; 
MEANING: 
The expression pointer-variable->member-name is a reference to 
the member of the object pointed to by pointer-variable. 
If member-name is a function, then that function is called. 
If member-name is a data field, then when the expression is 
used on the right-hand side of an assignment, it is the value of 
the data field. When the expression is used on the left-hand 
side of an assignment, then the referenced data field is assigned 
the value of the right-hand side. The expression 
pointer-variable->member-name 
is equivalent to 
(*pointer-variable).member-name 
but the -> operator is considered easier to read. 
Also, the -> operator can be overloaded, but the dot operator cannot.

PROGRAM STYLE 
When to Reference an Object through a Pointer Variable 
You have seen two different ways to create and reference 
Computer objects: Computer my_computer("Acme", "Intel P4 2.4", 512, 60); 
Computer* my_computer = new Computer("Acme", "Intel P4 2.4", 512, 60); 
What is the difference between these two statements? 
The first creates a type Computer object and references it through variable my_computer 
(for example, my_computer.to_string()). The second creates a Computer object and references 
it through a pointer to a Computer variable (for example, my_computer->to_string()). 
Use the first approach when you want the variable my_computer always to reference 
an object that is type Computer. Use the second approach when you want flexibility; 
it allows my_computer to reference an object of type Computer or any of its derived classes. 

SYNTAX 
Virtual Function Definition 
FORM: 
virtual function-declaration; 
virtual function-declaration { function-body } 
EXAMPLE: 
virtual std::string to_string() const; 
MEANING: 
If the function declared by function-declaration is overridden in a derived class, 
and if this function is called through a pointer to (or reference to) the base class, 
then the function body associated with the actual object pointed to (or referenced) 
will be executed. If a function is declared virtual in a base class, it continues 
to be virtual in all derived classes. It is, however, a good practice to include the 
virtual declaration in the derived classes too, for documentation purposes.

PITFALL 
Failure to Declare a Member Function virtual in a Base Class 
Generally, when we override a function, we intend to use polymorphism to 
reference objects of it and its derived classes. However, 
if we omit the keyword virtual, then the C++ compiler will determine 
the function to be called at compile time, based on the type of the pointer 
and not on the type of the object pointed to.

PITFALL 
Overridden Member Functions Must Have the Same Return Type 
If you write a member function in a derived class that has the same signature 
as one in the base class but a different return type, you will get an error message.

PROGRAM STYLE 
Declaring a virtual Destructor 
A class’s destructor is called when an object of that class is deleted or goes out of scope. 
Its purpose is to release any resources (such as dynamically allocated memory for 
classtype data members) that the class owns. Suppose a derived-class object is 
created using the new operator, and the pointer to it is stored in a pointer to 
the base-class variable. If the destructor is not virtual, then only the base-class 
destructor will be called when the delete operator is invoked through the pointer. 
Therefore, when you declare a member function to be virtual in a class, you should 
always declare the destructor virtual even if the destructor does nothing. 
In our Computer class example we should include the following: 
virtual ~Computer() {} 
This declares a virtual destructor that performs no operation. 
Some compilers will issue a warning message if the virtual destructor is omitted.

SYNTAX 
Abstract Function Definition 
FORM: 
virtual function-declaration = 0; 
EXAMPLE: 
virtual double percent_protein() const = 0; 
INTERPRETATION: 
The function declared by function-declaration is declared to be an abstract function. 
The expression = 0; 
is given in place of the function body and must be specified in the class declaration. 
You may also see the term pure virtual function to refer to an abstract function.

PITFALL 
Omitting the Definition of an Abstract Function in a Derived Class 
If you write class Vegetable and forget to define member function percent_protein, 
the class Vegetable will also be abstract. If you subsequently 
attempt to declare an object of type Vegetable, you will get a syntax error. 

DESIGN CONCEPT 
The Importance of Strong Typing 
Suppose C++ did not check the expression type and simply performed the assignment 
Lap_Top* a_laptop = new Computer( ... );    // Incompatible types 
Further down the line, we might attempt to apply a Lap_Top function to the object 
referenced by a_laptop. Because a_laptop is type Lap_Top*, the compiler would 
permit this. If a_laptop were pointing to a type Lap_Top object, 
then performing this operation would do no harm. But if a_laptop were 
pointing to an object that was not type Lap_Top, 
performing this operation would cause either a run-time error or 
an undetected logic error. It is much better to have the compiler 
tell us that the assignment is invalid.

SYNTAX 
Dynamic Cast 
FORM: 
dynamic_cast<class-name*>(object-name) 
EXAMPLE: 
dynamic_cast<Lap_Top*>(a_computer) 
INTERPRETATION: 
A pointer of type class-name is created to object object-name, 
provided that object-name is an actual object of type class-name 
(or a derived class of classname). If object-name is not type class-name, 
the result is a null pointer.

PITFALL 
Run-time Type Identification 
If you are using a Microsoft compiler, you may get a warning message 
that Run-time Type Identification is needed. 
You must set a compiler switch (/GR) to enable this or dynamic_cast will cause a 
run-time error.

SYNTAX 
Namespace Declaration 
FORM: 
namespace name { ... }
EXAMPLE: 
namespace game { ... }
INTERPRETATION: 
All identifiers (e.g., functions, variables, etc.) defined within the block 
following the name are within that namespace. Namespaces are open; 
this means that you may have more than one namespace declaration with 
the same name in your program. The identifiers defined within the different 
declarations are merged.

PROGRAM STYLE 
When to Use Namespaces 
The default namespace facility is intended for use during the early stages of 
implementing classes or for small prototype programs. If you are developing an 
application that has several classes that are part of a hierarchy of classes, 
you should declare them all to be in the same namespace. 
The namespace declaration will keep you from accidentally referring to classes by 
their short names in other classes that are outside the namespace.

SYNTAX 
using Declaration 
FORM: 
using namespace::name; 
EXAMPLE: 
using std::cout; 
MEANING: 
The qualified name is now a member of the namespace in which the using declaration appears. 
In this example, we can now use the name cout without prefixing the namespace qualifier 
std:: in front of it.

SYNTAX 
using Directive 
FORM: 
using namespace namespace-name; 
EXAMPLE: 
using namespace std; 
MEANING: 
All of the names defined in namespace-name are now defined as such within the current 
namespace.

PROGRAM STYLE 
A using Declaration Versus a using Directive 
You are probably in the habit of beginning your programs as follows: 
#include <iostream> 
// Other include directives 
using namespace std; 
... 
As long as your programs are small, this generally does not cause a problem. 
But you should recognize that the standard library is quite large and defines a 
very large number of names. In many implementations the include directive 
#include <iostream> brings in a large number of other headers. 
Many of these headers you would expect, such as <istream> and <ostream>, 
but it also may include some headers that you never heard of, such as <locale>, 
and others you may not expect, such as <string>. Therefore, if your program is going to 
access only cout, then a using declaration is preferred: 
#include <iostream> 
// Other include directives 
using std::cout; 
...

PROGRAM STYLE 
using Declarations and using Directives in Header Files 
Our definition of the class Person included a component of the class string from 
the standard library. You may be wondering why we didn’t write the header file as: 
#ifndef PERSON_H_ 
#define PERSON_H_ 
#include <string> 
using namespace std; 
class Person { 
... 
string name; 
}; 
Now assume that you start to write the game program we discussed in Example 3.6 and 
define your own class map. You decide that you need a Person class in your game program 
and use this revised header. Because class Person brings in all the names from 
namespace std, the game program will not compile, because there is now a 
name clash between your map and the standard map! Therefore, you should never 
place a using declaration or using directive inside a header file. Instead 
you should always explicitly qualify all names that are defined in a namespace 
with their namespace name; 
for example, 
std::cout.

SYNTAX 
friend Declaration 
FORM: 
friend function-name; 
friend class class-name; 
EXAMPLE: 
friend foo; 
MEANING: 
The named function or class is granted access to the private and 
protected members of the class in which the friend declaration appears.

SYNTAX 
Instantiating a Template Class
FORM: 
template-class-name<argument-list> object-name; 
EXAMPLE: 
some_container<int> call_lengths; 
some_container<Person> people; 
MEANING: 
If one doesn’t already exist, a distinct copy of the template class is created by 
substituting the arguments for the parameters. This is very similar to what happens 
when a function is called, except that this substitution occurs when the program 
is being compiled. Generally the arguments are types (either built-in or class types). 
In this example, two versions of the template class some_container are created: one to 
hold ints and the other to hold People objects. The classes some_container<int> and 
some_container<People> are distinct classes. 

PROGRAM STYLE 
Use of operator[] versus at 
As discussed in Chapter 2, the fact that C++ does not perform range checking on array 
bounds has led to many problems, including many security holes in modern operating systems. 
Unlike function at, the standard vector subscripting operator does not perform range 
checking, leaving the door open for these problems. Although the subscripting operator 
is more error prone, it is also more convenient to use, so most programmers use it 
rather than member function at. In the next section, we show how you to 
redefine the subscripting operator to perform range checking.

SYNTAX 
Defining a Template Class
FORM: 
template<formal-parameter-list> class class-name { ... } 
EXAMPLE: 
template<typename Item_Type> class vector { ... } 
template<class Item_Type> class bag { ... } 
template<typename Item_Type, size_t MAX_SIZE> class bounded_list { ... } 
MEANING: 
The class class-name is defined to take one or more template parameters. 
A template parameter follows the same syntax as a function parameter. 
type-name parameter-name 
where type-name is the name of the parameter’s type, and parameter-name is the 
identifier that is used to designate this parameter. Generally you use the keyword 
typename or the keyword class for type-name. This indicates that the parametername is to 
be treated as a type within the body of the template class. You can also declare 
additional parameters for the template class that are built-in types or previously 
defined class types (see the last example above). 
Note: The original C++ syntax used class to designate either classes or built-in types 
as template parameters, but the C++ standard introduced the alternative usage of typename 
as being a more accurate term. While typename is the preferred usage for new applications, 
the C++ standard uses class.



